{#pragma save_compiled_source ..\..\Resources\scripts\script.txt}

import "Utilities"
import "Functions/Functions.ksp"

on init
	message("")
	utilities.icb
	engine.ICB()
	tcm.init(1000)
	SET_CONDITION(TCM_LARGE)

	set_key_pressed_support(1)
	set_snapshot_type(3)

	declare dev_mode[1]
	load_array(dev_mode, 2)

	set_listener(NI_SIGNAL_TIMER_MS, 1000000/30) // 30 fps
	set_listener(NI_SIGNAL_TRANSP_START, 1)

	SET_CONDITION(NO_SYS_SCRIPT_PEDAL)

	declare i

	{{ Constants }}
	define UI_WIDTH  := 900
	define UI_HEIGHT := 427
	declare const NUM_ARTICULATIONS := 3
	declare const DOWN := 0
	declare const UP := 1
	declare const NUM_RRS := 4
	declare const MAX_NUM_CHORD_IDS := 1000
	define MAX_NUM_NOTES := 64
	define MAX_RIPPLE_HISTORY := 100
	const EVENT
		SOURCE // This has to be the first one
		LOW_NOTE
		HIGH_NOTE
		ROW
		DIRECTION
		ARTIC
		CHANNEL
		RELEASE_TIMESTAMP
		RELEASE_LENGTH
		BRIGHTNESS_ON_RELEASE
		FADING_OUT
		TRIGGERED_BY_MF
	end const
	define GRID_ROW_HEIGHT_CONST := 20
	define NUM_GRID_ROWS := 20
	declare !direction_strings[2] := ("triangle left", "triangle right")
	declare const RECORDED_DURATION_QUARTER := 545455
	declare const RECORDED_DURATION_EIGHTH := 272727
	declare const MAX_INTERVAL := 5
	declare const MIN_BRIGHTNESS := 24
	define CLIP_MARGIN := 4

	// Options constants
	const ARTIC
		QUARTERS
		EIGHTHS
		SIXTEENTHS
	end const

	const DIRECTION_MODE
		DOWN
		ASPLAYED
		UP
	end const

	const LEGATO_MODE
		OFF
		SYNC_TO_PITCH
		SYNC_TO_RIPPLE
		SYNC_TO_SWELL
	end const

	// Length constants
	declare sample_lengths[ARTIC.SIZE]
	sample_lengths[ARTIC.QUARTERS]   := RECORDED_DURATION_QUARTER * 16
	sample_lengths[ARTIC.EIGHTHS]    := RECORDED_DURATION_QUARTER * 8
	sample_lengths[ARTIC.SIXTEENTHS] := RECORDED_DURATION_QUARTER * 8

	declare recorded_pulse_lengths[ARTIC.SIZE]
	recorded_pulse_lengths[ARTIC.QUARTERS]   := RECORDED_DURATION_QUARTER * 2
	recorded_pulse_lengths[ARTIC.EIGHTHS]    := RECORDED_DURATION_QUARTER
	recorded_pulse_lengths[ARTIC.SIXTEENTHS] := RECORDED_DURATION_QUARTER

	declare pulse_lengths_ticks[ARTIC.SIZE]
	pulse_lengths_ticks[ARTIC.QUARTERS]   := 960*2
	pulse_lengths_ticks[ARTIC.EIGHTHS]    := 960
	pulse_lengths_ticks[ARTIC.SIXTEENTHS] := 960

	declare pitch_fractions[ARTIC.SIZE]
	pitch_fractions[ARTIC.QUARTERS]   := 2
	pitch_fractions[ARTIC.EIGHTHS]    := 2
	pitch_fractions[ARTIC.SIXTEENTHS] := 4

	// Keyswitches
	declare const LOWEST_KEY  := 36
	declare const HIGHEST_KEY := 72
	declare articulation_keyswitches[NUM_ARTICULATIONS] := (29, 31, 33)
	declare speed_keyswitches[NUM_SPEEDS]               := (72+5, 72+7, 72+9, 72+11, 72+12)
	declare direction_keyswitches[DIRECTION_MODE.SIZE]  := (72+14, 72+16, 72+17)
	declare legato_keyswitches[LEGATO_MODE.SIZE]        := (72+19, 72+21, 72+23, 72+24)
		
	// Formatted for Reascript:
	// articulation_keyswitches = {29, 31, 33}
	// speed_keyswitches        = {72+5, 72+7, 72+9, 72+11, 72+12}
	// direction_keyswitches    = {72+14, 72+16, 72+17}
	// legato_keyswitches       = {72+19, 72+21, 72+23, 72+24}

	// Fill the all_keyswitches array with all the other keyswitch arrays
	declare all_keyswitches[64]
	declare total_num_keyswitches
	for i := 0 to NUM_ARTICULATIONS - 1
		all_keyswitches[total_num_keyswitches] := articulation_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_SPEEDS - 1
		all_keyswitches[total_num_keyswitches] := speed_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to DIRECTION_MODE.SIZE - 1
		all_keyswitches[total_num_keyswitches] := direction_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to LEGATO_MODE.SIZE - 1
		all_keyswitches[total_num_keyswitches] := legato_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	

	{{ Variables }}
	declare num_keys_pressed[16]
	declare prev_num_keys_pressed[16]
	declare key_active[16, 128]
	declare key_down[128]
	declare key_timestamp[16, 128]
	declare note_ids[16, 128, NUM_GRID_ROWS]
	declare velo[16, 128]
	declare key_history[16, 100]
	declare ripple_history_by_channel[16, MAX_RIPPLE_HISTORY]
	declare ripple_history[MAX_RIPPLE_HISTORY]
	declare grid[128, NUM_GRID_ROWS]
	declare grid_for_half_steps[128, NUM_GRID_ROWS]
	declare highest_row
	declare prev_grid_row_height
	declare time_since_playing_notes
	declare direction
	declare row
	declare channel

	{{ Iterators }}
	declare hist_i
	declare par_i
	declare key_i
	declare ripple_i
	declare b
	declare v
	declare r
	declare k
	declare g
	declare n
	declare event_i
	declare other_event_i
	declare row_i
	declare vel_i
	declare clip_i
	declare @str := ""

	declare read grid_row_height := 20
	declare read cur_artic

	declare ~instructions_opacity := 1.0
	declare ~midiInstructions_opacity := 0.0
	declare ~midiCover_opacity := 0.0
	declare ~smoothed_midiInstructions_opacity
	declare ~smoothed_instructions_opacity
	declare ~smoothed_midiCover_opacity

	{{ UI }}
	import "F2K/UI Code.ksp"
	set_control_par_str(INST_ICON_ID, CONTROL_PAR_PICTURE, "insticon")

	// Midi clips
	define NUM_MIDI_CLIPS := 12

	declare read midi_event_id[NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_command [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_channel [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_pos     [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_byte_1  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_byte_2  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read midi_length  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare read clip_length  [NUM_MIDI_CLIPS]
	declare read clip_loop_enabled  [NUM_MIDI_CLIPS]
	declare read num_midi_events[NUM_MIDI_CLIPS]
	declare read num_midi_notes[NUM_MIDI_CLIPS]
	declare read num_midi_ccs[NUM_MIDI_CLIPS]
	declare time_started[NUM_MIDI_CLIPS]

	declare cur_event[NUM_MIDI_CLIPS]
    define clip_poly := NI_UI_ID -> custom_id
    define cur_event_poly := cur_event[NI_UI_ID -> custom_id]
    declare playing[NUM_MIDI_CLIPS]
    declare looping[NUM_MIDI_CLIPS]
    declare midi_file_pos_ticks[NUM_MIDI_CLIPS]
	define midi_file_pos_ticks_poly := midi_file_pos_ticks[NI_UI_ID -> custom_id]
	declare cb_id[NUM_MIDI_CLIPS]


	mf_reset()
	define MF_BUFFER_SIZE := 1000
	mf_set_buffer_size(MF_BUFFER_SIZE)
	mf_set_num_export_areas(NUM_MIDI_CLIPS + 1)
	// declare ui_label midi_clip[NUM_MIDI_CLIPS](2,2)
	mf_insert_file(get_folder(GET_FOLDER_PATCH_DIR) & "/../Data/midi.mid", 0, 0, 0)
	import "Assets/midi clip ids.ksp"
	declare ui_label mf_cursor[NUM_MIDI_CLIPS](2,2)
	for i := 0 to NUM_MIDI_CLIPS - 1
		mf_set_export_area("Ripple Cello", -1, -1, i, i)
		mf_copy_export_area(i + 1)
		midi_clip_id[i] -> midi_export_area_idx := i + 1
		midi_clip_id[i] -> dnd_behaviour := 1
		midi_clip_preview_id[i] -> z_layer := 1
		midi_clip_preview_id[i] -> custom_id := i
		midi_clip_preview_id[i] -> value := 0
		mf_cursor[i] -> picture := "mf_cursor"
		mf_cursor[i] -> hide := HIDE_WHOLE_CONTROL
		mf_cursor[i] -> parent_panel := midi_clip_panel_id[i]
		set_bounds(mf_cursor[i], 5, 0, 1, midi_clip_id[i] -> height)
	end for


	// Insert midi data into arrays to be played back
	fill(_midi_event_id, 0)
	fill(_midi_command, 0)
	fill(_midi_channel, 0)
	fill(_midi_pos, 0)
	fill(_midi_byte_1, 0)
	fill(_midi_byte_2, 0)
	fill(_midi_length, 0)
	fill(clip_length, 960*8)
	fill(num_midi_events, 0)
	fill(num_midi_notes, 0)
	fill(num_midi_ccs, 0)
	fill(clip_loop_enabled, 0)
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		// Notes
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_NOTE_ON
				midi_event_id[clip_i, num_midi_events[clip_i]] := mf_get_id()
				midi_command [clip_i, num_midi_events[clip_i]] := mf_get_command()
				midi_channel [clip_i, num_midi_events[clip_i]] := mf_get_channel()
				midi_pos     [clip_i, num_midi_events[clip_i]] := mf_get_pos()
				midi_byte_1  [clip_i, num_midi_events[clip_i]] := mf_get_byte_one()
				midi_byte_2  [clip_i, num_midi_events[clip_i]] := mf_get_byte_two()
				midi_length  [clip_i, num_midi_events[clip_i]] := mf_get_note_length()
				inc(num_midi_events[clip_i])
				inc(num_midi_notes[clip_i])
			end if
			mf_get_next(clip_i)
		end while

		// Insert pedal CC's at the correct times
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC and mf_get_byte_one() = 64
				declare cc_inserted
				cc_inserted := 0
				for event_i := 0 to num_midi_events[clip_i] - 1
					if cc_inserted = 0
						// Find which events to insert this CC between
						declare insert_index
						insert_index := -1

						// If it comes before the first event
						if event_i = 0
							if mf_get_pos() < midi_pos[clip_i, 0]
								insert_index := 0
								// message("inserted before the first event")
							end if
						end if

						// If it comes sandwiched between two events
						if in_range(event_i, 1, num_midi_events[clip_i] - 2)
							if mf_get_pos() > midi_pos[clip_i, event_i] and mf_get_pos() < midi_pos[clip_i, event_i + 1]
								insert_index := event_i + 1
							end if
						end if

						// If it comes after the last event
						if event_i = num_midi_events[clip_i] - 1
							if mf_get_pos() > midi_pos[clip_i, num_midi_events[clip_i] - 1]
								insert_index := num_midi_events[clip_i]
							end if
						end if

						// If it's right on another event
						if mf_get_pos() = midi_pos[clip_i, event_i]
							insert_index := event_i
							// message("right on another event: " & insert_index)
						end if

						if insert_index # -1
							cc_inserted := 1							

							// Move all following events back one slot
							for other_event_i := MF_BUFFER_SIZE - 1 downto insert_index + 1
								midi_event_id[clip_i, other_event_i] := midi_event_id[clip_i, other_event_i - 1]
								midi_command [clip_i, other_event_i] := midi_command [clip_i, other_event_i - 1]
								midi_channel [clip_i, other_event_i] := midi_channel [clip_i, other_event_i - 1]
								midi_pos     [clip_i, other_event_i] := midi_pos     [clip_i, other_event_i - 1]
								midi_byte_1  [clip_i, other_event_i] := midi_byte_1  [clip_i, other_event_i - 1]
								midi_byte_2  [clip_i, other_event_i] := midi_byte_2  [clip_i, other_event_i - 1]
								midi_length  [clip_i, other_event_i] := midi_length  [clip_i, other_event_i - 1]
							end for

							// Add CC
							midi_event_id[clip_i, insert_index] := mf_get_id()
							midi_command [clip_i, insert_index] := mf_get_command()
							midi_channel [clip_i, insert_index] := mf_get_channel()
							midi_pos     [clip_i, insert_index] := mf_get_pos()
							midi_byte_1  [clip_i, insert_index] := mf_get_byte_one()
							midi_byte_2  [clip_i, insert_index] := mf_get_byte_two()
						end if
					end if
				end for
				inc(num_midi_events[clip_i])
				inc(num_midi_ccs[clip_i])
			end if
			mf_get_next(clip_i)
		end while
	end for

	// Find clip lengths
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC
				if mf_get_byte_one() = 103
					clip_length[clip_i] := mf_get_pos()
					if mf_get_byte_two() = 127
						clip_loop_enabled[clip_i] := 1
					else
						clip_loop_enabled[clip_i] := 0
					end if
					// mf_remove_event(mf_get_id()) // clean up
				end if
			end if
			mf_get_next(clip_i)
		end while
	end for




	label_midiCover -> z_layer := 0
	panel_midiPg0 -> z_layer := 1

	switch_showMidi := 0
	update_midi_visibility()

	switch_info -> hide := HIDE_WHOLE_CONTROL

	declare key_ids[128]
	declare key_base_ids[128]
	import "Assets/keyboard_ids.ksp"

	for key_i := LOWEST_KEY to HIGHEST_KEY
		key_ids[key_i] -> value := 0
	end for

	// Articulations
	declare articulation_ids[NUM_ARTICULATIONS]
	articulation_ids[0] := get_ui_id(switch_quarters)
	articulation_ids[1] := get_ui_id(switch_eighths)
	articulation_ids[2] := get_ui_id(switch_sixteenths)

	// Speed
	define NUM_SPEEDS := 5
	declare speed_ids[NUM_SPEEDS]
	speed_ids[0] := get_ui_id(switch_halfSpeed)
	speed_ids[1] := get_ui_id(switch_slowTripletSpeed)
	speed_ids[2] := get_ui_id(switch_fullSpeed)
	speed_ids[3] := get_ui_id(switch_fastTripletSpeed)
	speed_ids[4] := get_ui_id(switch_doubleSpeed)
	declare !speed_texts[5] := ("0.5", "0.75", "1.0", "1.5", "2.0")
	for i := 0 to num_elements(speed_ids) - 1
		speed_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		speed_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		speed_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		speed_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		speed_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		speed_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		speed_ids[i] -> text := speed_texts[i]
		speed_ids[i] -> width := speed_ids[i] -> width + 14
	end for
	switch_halfSpeed        -> pos_x := switch_halfSpeed        -> pos_x - 4
	switch_slowTripletSpeed -> pos_x := switch_slowTripletSpeed -> pos_x - 6
	switch_fullSpeed        -> pos_x := switch_fullSpeed        -> pos_x - 4
	switch_fastTripletSpeed -> pos_x := switch_fastTripletSpeed -> pos_x - 3
	switch_doubleSpeed      -> pos_x := switch_doubleSpeed      -> pos_x - 6

	// Direction
	switch_up       -> text := "Up"
	switch_down     -> text := "Down"
	switch_asPlayed -> text := "As Played"
	declare direction_mode_ids[DIRECTION_MODE.SIZE]
	direction_mode_ids[0] := get_ui_id(switch_down)
	direction_mode_ids[1] := get_ui_id(switch_asPlayed)
	direction_mode_ids[2] := get_ui_id(switch_up)
	for i := 0 to num_elements(direction_mode_ids) - 1
		direction_mode_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		direction_mode_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		direction_mode_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		direction_mode_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		direction_mode_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		direction_mode_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		// direction_mode_ids[i] -> text := speed_texts[i]
	end for
	switch_down     -> width := switch_down     -> width + 13
	switch_asPlayed -> width := switch_asPlayed -> width + 19
	switch_up       -> width := switch_up       -> width + 7

	// Legato/Quantize
	switch_noLegato     -> text := "Off"
	switch_syncToPitch  -> text := "Pitch"
	switch_syncToRipple -> text := "Ripple"
	switch_syncToSwell  -> text := "Swell"
	declare legato_ids[LEGATO_MODE.SIZE]
	legato_ids[0] := get_ui_id(switch_noLegato)
	legato_ids[1] := get_ui_id(switch_syncToPitch)
	legato_ids[2] := get_ui_id(switch_syncToRipple)
	legato_ids[3] := get_ui_id(switch_syncToSwell)
	for i := 0 to num_elements(legato_ids) - 1
		legato_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		legato_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		legato_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		legato_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		legato_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		legato_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		// direction_mode_ids[i] -> text := speed_texts[i]
	end for
	switch_noLegato     -> width := switch_noLegato     -> width + 4
	switch_syncToPitch  -> width := switch_syncToPitch  -> width + 12
	switch_syncToRipple -> width := switch_syncToRipple -> width + 12
	switch_syncToSwell  -> width := switch_syncToSwell  -> width + 16

	slider_speed     -> mouse_behaviour := 1500
	slider_direction -> mouse_behaviour := 1500
	slider_legato    -> mouse_behaviour := 1500

	slider_speed     -> default := 2
	slider_direction -> default := 1
	slider_legato    -> default := 0

	slider_vol -> default := V2E.volume(0.0)
	slider_reverb -> default := 500000

	menu_reverb -> textpos_y := 100


	// Old
	declare ui_slider bracket[MAX_NUM_NOTES, 9](0, 1000)
	for i := 0 to bracket.size_D1 - 1
		for v := 0 to bracket.size_D2 - 1
			set_bounds(bracket[i, v], 20 + i * 18, 100 + (bracket.size_D2 - v) * 18, 13, 13)
			bracket[i, v] -> hide := HIDE_WHOLE_CONTROL
			bracket[i, v] -> picture := "circle"
		end for
	end for

	set_voice_limit(NI_VL_TMPRO_STANDARD, MAX_RIPPLE_HISTORY)
	declare ui_slider ripple[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple) - 1
		// ripple[i] -> picture := "ripple 0"
		ripple[i] -> z_layer := 1
		ripple[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	declare ui_slider ripple_swell[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple_swell) - 1
		// ripple_swell[i] -> picture := "ripple_swell 0"
		ripple_swell[i] -> z_layer := 1
		ripple_swell[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	declare ui_slider dot[MAX_RIPPLE_HISTORY](0, 127)
	for i := 0 to num_elements(dot) - 1
		dot[i] -> picture := "triangle right"
		dot[i] -> hide := HIDE_WHOLE_CONTROL
		dot[i] -> value := 1000
		dot[i] -> pos_x := 0
		dot[i] -> pos_y := 0
		dot[i] -> z_layer := 1
	end for


	// DEV

	group[ARTIC.QUARTERS].speed   := V2E_speed(18*2)
	group[ARTIC.EIGHTHS].speed    := V2E_speed(18)
	group[ARTIC.SIXTEENTHS].speed := V2E_speed(18)
end on

on persistence_changed
	call set_key_colors
	call set_keys_pressed
end on

on note
	set_event_par_arr(EVENT_ID, EVENT_PAR_CUSTOM, OUTSIDE_SOURCE, EVENT.SOURCE)
	set_event_par_arr(EVENT_ID, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
	note_callback(EVENT_NOTE, EVENT_VELOCITY, EVENT_ID)
end on

function note_callback(note, velocity, event_id)
	set_key_pressed(note, 1)
	key_down[note] := 1
	declare channel := event_id -> midi_channel

	// Keyswitches
	declare ks_index := search(articulation_keyswitches, note)
	if ks_index # -1
		cur_artic := ks_index
		call update_articulation_switches
	end if

	ks_index := search(speed_keyswitches, note)
	if ks_index # -1
		slider_speed := ks_index
		call update_speed_switches
	end if

	ks_index := search(direction_keyswitches, note)
	if ks_index # -1
		slider_direction := ks_index
		call update_direction_switches
	end if

	ks_index := search(legato_keyswitches, note)
	if ks_index # -1
		slider_legato := ks_index
		call update_legato_switches
	end if

	if search(all_keyswitches, note) # -1
		call set_keys_pressed
	end if

	// Playable range
	if in_range(note, LOWEST_KEY, HIGHEST_KEY)
		// Key arrays
		key_active   [channel, note] := 1
		key_timestamp[channel, note] := ENGINE_UPTIME
		velo         [channel, note] := velocity

		// UI keyboard
		key_ids[note]      -> picture_state := 1

		// Keys history
		for key_i := key_history.SIZE_D2 - 2 downto 0
			key_history[channel, key_i + 1]   := key_history[channel, key_i]
		end for
		key_history[channel, 0]   := note

		count_keys_pressed(channel)
		if num_keys_pressed[channel] > 1
			declare notes[MAX_NUM_NOTES]
			declare intervals[MAX_NUM_NOTES]
			define MAX_NUM_RIPPLES_PER_NOTE := 12
			declare notes[MAX_NUM_RIPPLES_PER_NOTE]
			declare intervals[MAX_NUM_RIPPLES_PER_NOTE]
			declare num_ripples := 0

			// Fill neighbor arrays, to be analyzed later
			declare closest_neighbor := -1
			declare closest_neighbor_interval := 12
			declare neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare lower_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare upper_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			fill(neighbor, 0)
			fill(lower_neighbor, 0)
			fill(upper_neighbor, 0)
			declare num_neighbors := 0
			declare num_lower_neighbors := 0
			declare num_upper_neighbors := 0

			for i := 1 to MAX_INTERVAL
				// Look below and above
				declare dir
				for dir := 0 to 1
					declare sign := dir*2-1
					declare other_note := note + i*sign
					if key_down[other_note] = 1
						neighbor[num_neighbors] := other_note
						inc(num_neighbors)
						if other_note < note
							lower_neighbor[num_lower_neighbors] := other_note
							inc(num_lower_neighbors)
						end if
						if other_note > note
							upper_neighbor[num_upper_neighbors] := other_note
							inc(num_upper_neighbors)
						end if
					end if
				end for
			end for

			if lower_neighbor[0] # 0 and upper_neighbor[0] # 0
				declare lower_neighbor_time_held := ENGINE_UPTIME - key_timestamp[channel, lower_neighbor[0]]
				declare upper_neighbor_time_held := ENGINE_UPTIME - key_timestamp[channel, upper_neighbor[0]]
				if abs(upper_neighbor_time_held - lower_neighbor_time_held) < 50
					// Make ripples to both adjacent neighbors. They were played as a chord
					notes[0] := lower_neighbor[0]
					intervals[0] := note - lower_neighbor[0]
					notes[1] := upper_neighbor[0]
					intervals[1] := note - upper_neighbor[0]
					num_ripples := 2
				else
					// Only make ripples to the most recent adjacent neighbor
					declare channel_history[key_history.SIZE_D2]
					declare hist_i
					for hist_i := 0 to key_history.SIZE_D2 - 1
						channel_history[hist_i] := key_history[channel, hist_i]
					end for
					if search(channel_history, lower_neighbor[0]) < search(channel_history, upper_neighbor[0])
						// lower neighbor happened more recently
						notes[0] := lower_neighbor[0]
						intervals[0] := note - lower_neighbor[0]
					else
						// upper neighbor happened more recently
						notes[0] := upper_neighbor[0]
						intervals[0] := note - upper_neighbor[0]
					end if
					num_ripples := 1
				end if
			else
				// Add ripple based on history
				notes[0]     := key_history[channel, 1]
				intervals[0] := key_history[channel, 0] - key_history[channel, 1]
				num_ripples := 1

				if abs(intervals[0]) > MAX_INTERVAL
					if num_neighbors > 0
						// If ripples can't be made using history, use closest neighbor, up or down
						notes[0] := neighbor[0]
						intervals[0] := note - neighbor[0]
						num_ripples := 1
					else 
						// If that doesn't work, then don't make any ripples at all
						fill(notes, 0)
						fill(intervals, 0)
						num_ripples := 0
					end if
				end if
			end if

			declare ripple_i
			for ripple_i := 0 to num_ripples - 1
				// Swap notes and intervals to change directions
				if slider_direction = DIRECTION_MODE.UP
					if intervals[ripple_i] < 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				else if slider_direction = DIRECTION_MODE.DOWN
					if intervals[ripple_i] > 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				end if

				// Get low and high notes
				if intervals[ripple_i] < 0
					declare low_note := notes[ripple_i] + intervals[ripple_i]
					declare high_note := notes[ripple_i]
				else
					low_note := notes[ripple_i]
					high_note := notes[ripple_i] + intervals[ripple_i]
				end if

				// Direction
				if intervals[ripple_i] > 0
					direction := UP
				else
					direction := DOWN
				end if

				// Make sure this particular interval and direction isn't already being played
				declare already_playing := 0
				for r := 0 to MAX_RIPPLE_HISTORY - 1
					if ripple_history[r] # 0
						if  get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.LOW_NOTE) = low_note...
						and get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.HIGH_NOTE) = high_note...
						and get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.DIRECTION) = direction...
						and get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.FADING_OUT) = 0
							already_playing := 1
						end if
					end if
				end for

				if already_playing = 0
					declare active_note_id := find_first_active_event()
					declare offset
					select slider_legato
						case LEGATO_MODE.OFF
							offset := 0
						case LEGATO_MODE.SYNC_TO_PITCH
							offset := active_note_id -> play_pos mod (recorded_pulse_lengths[cur_artic] / pitch_fractions[cur_artic])
						case LEGATO_MODE.SYNC_TO_RIPPLE
							offset := active_note_id -> play_pos mod recorded_pulse_lengths[cur_artic]
						case LEGATO_MODE.SYNC_TO_SWELL
							offset := active_note_id -> play_pos mod sample_lengths[cur_artic]
					end select
					declare note_id := play_note(notes[ripple_i], 64 + intervals[ripple_i], offset, 0)
					declare volume  := map_i_2i_2i_i(velocity, 1, 127, -12000, 3000)
					if offset = 0
						// tmpro causes a bit of a bump sometimes. This hides that.
						fade_in(note_id, DURATION_SIXTEENTH)
					end if
					change_vol(note_id, volume, CHANGE_ABSOLUTE)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, cur_artic)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, cur_artic, EVENT.ARTIC)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, low_note,  EVENT.LOW_NOTE)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, high_note, EVENT.HIGH_NOTE)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, channel,   EVENT.CHANNEL)
					// set_event_par_arr(note_id, EVENT_PAR_CUSTOM, r,   EVENT.RIPPLE_INDEX)
					// set_event_par_arr(note_id, EVENT_PAR_CUSTOM, row, EVENT.ROW)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, direction, EVENT.DIRECTION)
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, OUTSIDE_SOURCE, EVENT.SOURCE)

					for r := MAX_RIPPLE_HISTORY - 2 downto 0
						ripple_history_by_channel[channel, r + 1] := ripple_history_by_channel[channel, r]
						ripple_history[r + 1] := ripple_history[r]
					end for
					ripple_history_by_channel[channel, 0] := note_id
					ripple_history[0] := note_id
					if offset > 0
						declare recorded_pos_in_pulse := note_id -> play_pos mod recorded_pulse_lengths[cur_artic]
						declare actual_pos_in_pulse := map_i_2i_2i_i(recorded_pos_in_pulse, 0, recorded_pulse_lengths[cur_artic], 0, ticks_to_ms(pulse_lengths_ticks[cur_artic]))
						declare fade_in_time := ticks_to_ms(pulse_lengths_ticks[cur_artic]) - actual_pos_in_pulse
						constrain(fade_in_time, DURATION_SIXTEENTH, ticks_to_ms(pulse_lengths_ticks[cur_artic]) / 4 * 3)
						fade_in(note_id, fade_in_time)
					end if

				end if
			end for
		end if
	end if
end function

function release(channel, note)
	declare r
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_history[r] # 0 ...
		and get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.FADING_OUT) = 0
			if channel = get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.CHANNEL)
				declare low_note  := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.LOW_NOTE)
				declare high_note := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.HIGH_NOTE)
				if low_note = note or high_note = note
					declare artic := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.ARTIC)
					declare recorded_pos_in_pulse := ripple_history[r] -> play_pos mod recorded_pulse_lengths[artic]
					declare actual_pos_in_pulse := map_i_2i_2i_i(recorded_pos_in_pulse, 0, recorded_pulse_lengths[artic], 0, ticks_to_ms(pulse_lengths_ticks[artic]))
					declare fade_out_time := ticks_to_ms(pulse_lengths_ticks[artic]) - actual_pos_in_pulse
					constrain(fade_out_time, DURATION_SIXTEENTH, ticks_to_ms(pulse_lengths_ticks[artic]) / 4 * 3)
					fade_out(ripple_history[r], fade_out_time, STOP_VOICE_AFTER_FADE_OUT)
					set_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, ENGINE_UPTIME, EVENT.RELEASE_TIMESTAMP)
					set_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, fade_out_time, EVENT.RELEASE_LENGTH)
					set_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, 1, EVENT.FADING_OUT)
				end if
			end if
		end if
	end for
end function


function release_callback(note, event_id)
	key_down[note] := 0
	if search(all_keyswitches, note) = -1
		set_key_pressed(note, 0)
	end if

	declare source := get_event_par_arr(event_id, EVENT_PAR_CUSTOM, EVENT.SOURCE)
	if in_range(note, LOWEST_KEY, HIGHEST_KEY) and source = OUTSIDE_SOURCE
		declare channel := event_id -> midi_channel
		key_ids[note] -> picture_state := 0

		// move all history
		declare history_index := search_for_note_in_channel_history(channel, note)
		if history_index > -1
			for key_i := history_index to key_history.SIZE_D2 - 2
				key_history[channel, key_i]   := key_history[channel, key_i + 1]
			end for
		end if
			
		if CC[64] < 10
			key_active[channel, note] := 0
			release(channel, note)
		end if
	end if
end function

on release
	release_callback(EVENT_NOTE, EVENT_ID)
end on

function controller_callback(cc_num)
	if cc_num = 64
		declare prev_cc64
		if CC[64] < 10 and prev_cc64 >= 10
			declare key_i
			declare c
			for c := 0 to 15
				for key_i := 0 to 127
					if key_down[key_i] = 0 and key_active[c, key_i] = 1
						key_active[c, key_i] := 0
						release(c, key_i)
					end if
				end for
			end for
		end if
		prev_cc64 := CC[64]
	end if
end function
on controller
	controller_callback(CC_NUM)
end on


on listener
	listener_callback()
end on
function listener_callback
	if NI_SIGNAL_TYPE = NI_SIGNAL_TIMER_MS
		declare r

		// Hide faded-out ripples and remove them from history
		for r := 0 to MAX_RIPPLE_HISTORY - 1
			if event_status(ripple_history[r]) = EVENT_STATUS_INACTIVE and ripple_history[r] # 0
				ripple[r] -> hide  := HIDE_WHOLE_CONTROL
				dot[r] -> hide := HIDE_WHOLE_CONTROL
				for hist_i := r to MAX_RIPPLE_HISTORY - 2
					ripple_history_by_channel[channel, hist_i] := ripple_history_by_channel[channel, hist_i + 1]
					ripple_history[hist_i] := ripple_history[hist_i + 1]
				end for
			end if
		end for

		// Clear grid array
		for key_i := LOWEST_KEY to HIGHEST_KEY
			for row_i := 0 to NUM_GRID_ROWS - 1
				grid[key_i, row_i] := 0
				grid_for_half_steps[key_i, row_i] := 0
			end for
		end for

		// Fill grid array, finding collisions and assigning rows for each ripple history event id
		highest_row := 0
		for r := MAX_RIPPLE_HISTORY - 1 downto 0
			if ripple_history[r] # 0
				declare low_note  := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.LOW_NOTE)
				declare high_note := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.HIGH_NOTE)
				declare interval  := high_note - low_note

				// Find collision using the grid, to figure out which row to put this ripple on
				row := 0
				declare found_free_row := 0
				for row_i := 0 to NUM_GRID_ROWS - 1
					if found_free_row = 0
						declare collision_found := 0
						for key_i := low_note+1 to high_note-1
							if grid[key_i, row_i] = 1
								collision_found := 1
							end if
						end for
						if abs(interval) = 1
							if grid[low_note, row_i] = 1 ...
							and grid[high_note, row_i] = 1
								collision_found := 1
							end if
							if grid_for_half_steps[low_note, row_i] = 1 ...
							and grid_for_half_steps[high_note, row_i] = 1
								collision_found := 1
							end if
						end if
						if collision_found = 0
							found_free_row := 1
							row := row_i
						end if
					end if
				end for

				if found_free_row = 1
					if row > highest_row
						highest_row := row
					end if
					set_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, row, EVENT.ROW)
					for key_i := low_note to high_note
						grid[key_i, row] := 1
						if abs(interval) = 1
							grid_for_half_steps[key_i, row] := 1
						end if
					end for
				end if
			end if
		end for

		// Get grid row height
		if highest_row >= 3
			grid_row_height := 134 / (highest_row+1)
		else
			grid_row_height := 134 / 4
		end if

		// Draw and animate ripples
		for r := MAX_RIPPLE_HISTORY - 1 downto 0
			if event_status(ripple_history[r]) = EVENT_STATUS_NOTE_QUEUE
				if get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.FADING_OUT) = 0
					// Animation Variables
					declare low_note  := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.LOW_NOTE)
					declare high_note := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.HIGH_NOTE)
					declare direction := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.DIRECTION)
					declare interval  := (high_note - low_note) * (direction * 2 - 1)
					
					declare channel := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.CHANNEL)
					declare artic := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.ARTIC)
					declare ~speed_curve
					declare ~brightness_curve
					if artic = ARTIC.QUARTERS
						speed_curve := 1.0
						brightness_curve := 5.0
					else if artic = ARTIC.EIGHTHS
						speed_curve := 1.5
						brightness_curve := 2.0
					else if artic = ARTIC.SIXTEENTHS
						speed_curve := 0.75
						brightness_curve := 2.0
					end if


					// Ripple position
					low_note  := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.LOW_NOTE)
					high_note := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.HIGH_NOTE)
					row       := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.ROW)
					channel   := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.CHANNEL)
					ripple[r] -> pos_x   := panel_keyboard -> pos_x + key_ids[low_note]  -> pos_x + (key_ids[low_note]  -> width / 2)
					if interval < 0
						ripple[r] -> pos_y := panel_keyboard -> pos_y - (22*abs(interval)+1) / 2 - 1
					else
						ripple[r] -> pos_y := panel_keyboard -> pos_y + key_ids[LOWEST_KEY] -> height - (22*abs(interval)+1) / 2 - 1
					end if
					// ripple[r] -> width   := stop - start
					// ripple[r] -> height  := grid_row_height * (row+1)
					// ripple[r] -> picture := "ripple " & channel
					// ripple[r] -> picture := "Ripples/sized/ripple circle " & stop - start
					ripple[r] -> picture := "ripple " & interval & " ch " & channel+1

					// Play Ripple animation
					declare play_pos_in_beat := ripple_history[r] -> play_pos mod recorded_pulse_lengths[artic]
					ripple[r] -> value := map_i_2i_2i_i(play_pos_in_beat, 0, recorded_pulse_lengths[artic], 0, 127)

					// Ripple visiblity
					ripple[r] -> hide := HIDE_PART_NOTHING


					// Ripple swell
					ripple_swell[r] -> pos_x := ripple[r] -> pos_x
					ripple_swell[r] -> pos_y := ripple[r] -> pos_y
					ripple_swell[r] -> picture := "ripple swell " & interval & " ch " & channel+1
					declare pos_in_swell := ripple_history[r] -> play_pos mod sample_lengths[artic]
					if in_range(pos_in_swell, 0, sample_lengths[artic] / 2)
						ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, 0, sample_lengths[artic] / 2, 0, 64)
					else
						ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, sample_lengths[artic] / 2, sample_lengths[artic], 64, 0)
					end if
					ripple_swell[r] -> hide := ripple[r] -> hide
					ripple_swell[r] -> hide := HIDE_PART_NOTHING
					set_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, ripple_swell[r] -> value, EVENT.BRIGHTNESS_ON_RELEASE)


					// Dot brightness
					declare play_pos_in_beat := ripple_history[r] -> play_pos mod recorded_pulse_lengths[artic]
					dot[r] -> picture := direction_strings[get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.DIRECTION)]
					declare ~play_pos_in_beat_norm := real(play_pos_in_beat) / real(recorded_pulse_lengths[artic])
					declare play_pos_in_beat_curved := int(pow(play_pos_in_beat_norm, brightness_curve) * 127.0)
					dot[r] -> value := map_i_2i_2i_i(play_pos_in_beat, 0, recorded_pulse_lengths[artic], 127-play_pos_in_beat_curved, 0)

					// Dot position
					declare direction := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.DIRECTION)
					if direction = UP
						declare start := ripple[r] -> pos_x + 2
						declare stop := ripple[r] -> pos_x + ripple[r] -> width - 5 - 2 + 10
					else
						start := ripple[r] -> pos_x + 2 - 20
						stop := ripple[r] -> pos_x + ripple[r] -> width - 5
					end if
					~play_pos_in_beat_norm := real(play_pos_in_beat) / real(recorded_pulse_lengths[artic])
					play_pos_in_beat_curved := int(pow(play_pos_in_beat_norm, speed_curve) * 1000000.0)
					if direction = UP
						dot[r] -> pos_x := map_i_2i_2i_i(play_pos_in_beat_curved, 0, 1000000, start, stop)
					else
						dot[r] -> pos_x := map_i_2i_2i_i(play_pos_in_beat_curved, 0, 1000000, stop, start)
					end if
					dot[r] -> pos_y := ripple[r] -> pos_y - 10

					// Dot visibility
					// if get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.FADING_OUT) = 0
					// 	dot[r] -> hide := HIDE_PART_NOTHING
					// else
					// 	dot[r] -> hide := HIDE_WHOLE_CONTROL
					// end if

				else
					// Fade out ripples
					dot[r] -> hide := HIDE_WHOLE_CONTROL
					ripple[r] -> hide := HIDE_WHOLE_CONTROL
					if ripple_swell[r] -> value > 0
						declare time_since_release := ENGINE_UPTIME - get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.RELEASE_TIMESTAMP)
						declare release_length     := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.RELEASE_LENGTH) / 1000
						declare brightness_on_release := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.BRIGHTNESS_ON_RELEASE)
						ripple_swell[r] -> value := map_i_2i_2i_i(time_since_release, 0, release_length, brightness_on_release, 0)
					end if
				end if
			else
				ripple[r] -> hide  := HIDE_WHOLE_CONTROL
				ripple_swell[r] -> hide  := HIDE_WHOLE_CONTROL
				dot[r] -> hide := HIDE_WHOLE_CONTROL
			end if
		end for

		// Midi file play cursors
		for clip_i := 0 to NUM_MIDI_CLIPS - 1
			if midi_clip_preview_id[clip_i] -> value = 1
				mf_cursor[clip_i] -> hide := HIDE_PART_NOTHING
				declare time_played := ENGINE_UPTIME - time_started[clip_i]
				declare clip_length_milli := ticks_to_ms(clip_length[clip_i]) / 1000
				mf_cursor[clip_i] -> pos_x := map_i_2i_2i_i(time_played, 0, clip_length_milli, CLIP_MARGIN, midi_clip_id[clip_i] -> width - CLIP_MARGIN)
			else
				mf_cursor[clip_i] -> hide := HIDE_WHOLE_CONTROL
			end if
		end for


		if PLAYED_VOICES_INST > 0 
			instructions_opacity := 0.0
			midiInstructions_opacity := 0.0
		end if
		smoothed_instructions_opacity := smoothed_instructions_opacity + (instructions_opacity - smoothed_instructions_opacity) / 30.0
		if ~smoothed_instructions_opacity < 0.0001
			~smoothed_instructions_opacity := 0.0
		end if
		label_instructions -> picture_state := map_f_2f_2i_i(smoothed_instructions_opacity, 0.0, 1.0, 0, 127)
		smoothed_midiInstructions_opacity := smoothed_midiInstructions_opacity + (midiInstructions_opacity - smoothed_midiInstructions_opacity) / 30.0
		if ~smoothed_midiInstructions_opacity < 0.0001
			~smoothed_midiInstructions_opacity := 0.0
		end if
		label_midiInstructions -> picture_state := map_f_2f_2i_i(smoothed_midiInstructions_opacity, 0.0, 1.0, 0, 127)
		smoothed_midiCover_opacity := smoothed_midiCover_opacity + (midiCover_opacity - smoothed_midiCover_opacity) / 4.0
		if ~smoothed_midiCover_opacity < 0.0001
			~smoothed_midiCover_opacity := 0.0
		end if
		label_midiCover -> picture_state := map_f_2f_2i_i(smoothed_midiCover_opacity, 0.0, 1.0, 0, 127)

		// Crossfaded looping
		for r := 0 to MAX_RIPPLE_HISTORY - 1
			if event_status(ripple_history[r]) = EVENT_STATUS_NOTE_QUEUE ...
			and get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, EVENT.FADING_OUT) = 0 ...
			and ripple_history[r] -> play_pos > sample_lengths[cur_artic]
				// duplicate event
				declare note     := ripple_history[r] -> note
				declare velocity := ripple_history[r] -> velocity
				declare volume := ripple_history[r] -> volume
				declare event_pars[EVENT.SIZE]
				for par_i := 0 to EVENT.SIZE - 1
					event_pars[par_i] := get_event_par_arr(ripple_history[r], EVENT_PAR_CUSTOM, par_i)
				end for
				fade_out(ripple_history[r], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
				declare offset := ripple_history[r] -> play_pos mod sample_lengths[artic]
				declare note_id := play_note(note, velocity, offset, 0)
				set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
				set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, event_pars[EVENT.ARTIC])
				change_vol(note_id, volume, CHANGE_ABSOLUTE)
				fade_in(note_id, DURATION_SIXTEENTH)
				for par_i := 0 to EVENT.SIZE - 1
					set_event_par_arr(note_id, EVENT_PAR_CUSTOM, event_pars[par_i], par_i)
				end for
				ripple_history[r] := note_id
				ripple_history_by_channel[event_pars[EVENT.CHANNEL], r] := note_id
			end if
		end for
	end if

end function


function update_articulation_switches
	for i := 0 to num_elements(articulation_ids) - 1
		if i = cur_artic
			articulation_ids[i] -> value := 1
		else
			articulation_ids[i] -> value := 0
		end if
	end for
end function

function update_speed_switches
	for i := 0 to num_elements(speed_ids) - 1
		if i = slider_speed
			speed_ids[i] -> value := 1
		else
			speed_ids[i] -> value := 0
		end if
	end for
end function

function update_direction_switches
	for i := 0 to num_elements(direction_mode_ids) - 1
		if i = slider_direction
			direction_mode_ids[i] -> value := 1
		else
			direction_mode_ids[i] -> value := 0
		end if
	end for
end function

function update_legato_switches
	for i := 0 to num_elements(legato_ids) - 1
		if i = slider_legato
			legato_ids[i] -> value := 1
		else
			legato_ids[i] -> value := 0
		end if
	end for
end function


on ui_controls
	ui_controls_callback()
end on

function ui_controls_callback()
	declare index

	// Show midi
	if NI_UI_ID = get_ui_id(switch_showMidi)
		call update_midi_visibility
	end if
	if NI_UI_ID = get_ui_id(switch_closeMidi)
		switch_showMidi := 0
		call update_midi_visibility
	end if

	// Info
	if NI_UI_ID = get_ui_id(switch_openInfo)
		if switch_info -> hide = HIDE_WHOLE_CONTROL
			switch_info -> hide := HIDE_PART_NOTHING
		else
			switch_info -> hide := HIDE_WHOLE_CONTROL
		end if
	end if

	index := search(midi_clip_preview_id, NI_UI_ID)
	if index # -1
		if NI_UI_ID -> value = 0
			playing[clip_poly] := 0
			looping[clip_poly] := 0

			declare event_ids[128]
			get_event_ids(event_ids)
			declare e
			for e := 0 to num_elements(event_ids) - 1
				if get_event_par_arr(event_ids[e], EVENT_PAR_CUSTOM, EVENT.TRIGGERED_BY_MF) = clip_poly + 1
					declare note := event_ids[e] -> note
					release_callback(note, event_ids[e])
				end if
			end for

			cb_id[clip_poly] := NI_CALLBACK_ID
		else
			cb_id[clip_poly] := NI_CALLBACK_ID

			// Release any other midi notes that may be going
			declare other_clip_i
			for other_clip_i := 0 to num_elements(midi_clip_preview_id) - 1
				if index # other_clip_i
					midi_clip_preview_id[other_clip_i] -> value := 0
					if playing[other_clip_i] = 1
						declare event_ids[128]
						get_event_ids(event_ids)
						declare e
						for e := 0 to num_elements(event_ids) - 1
							if get_event_par_arr(event_ids[e], EVENT_PAR_CUSTOM, EVENT.TRIGGERED_BY_MF) = other_clip_i + 1
								note := event_ids[e] -> note
								release_callback(note, event_ids[e])
							end if
						end for
						playing[other_clip_i] := 0
						looping[other_clip_i] := 0
					end if
				end if
			end for

			//Play
			looping[clip_poly] := 1
			while looping[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
				if clip_loop_enabled[clip_poly] = 0
					looping[clip_poly] := 0
				end if
				if switch_showMidi = 0
					looping[clip_poly] := 0
				end if

				cur_event_poly := 0
				
				midi_file_pos_ticks_poly := 0
				time_started[clip_poly] := ENGINE_UPTIME

				playing[clip_poly] := 1
				while playing[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
					if cur_event_poly = num_midi_events[clip_poly]
						declare ticks_until_next_event := clip_length[clip_poly] - midi_file_pos_ticks_poly
					else
						ticks_until_next_event := midi_pos[clip_poly, cur_event_poly] - midi_file_pos_ticks_poly
					end if

					if ticks_until_next_event > 0
						wait(ticks_to_ms(ticks_until_next_event))
					end if

					macro check_if_it_should_be_playing
						if cur_event_poly > num_midi_events[clip_poly]
							playing[clip_poly] := 0
						end if
						if switch_showMidi = 0
							playing[clip_poly] := 0
						end if
					end macro
					check_if_it_should_be_playing()

					if playing[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
						midi_file_pos_ticks_poly := midi_file_pos_ticks_poly + ticks_until_next_event
						if midi_command[clip_poly, cur_event_poly] = MIDI_COMMAND_NOTE_ON
							declare channel  := midi_channel[clip_poly, cur_event_poly]
							declare note     := midi_byte_1[clip_poly, cur_event_poly]
							declare velocity := midi_byte_2[clip_poly, cur_event_poly]
							declare length   := ticks_to_ms(midi_length[clip_poly, cur_event_poly])
							declare note_id := play_note(note, velocity, 0, length)
							note_id -> midi_channel := channel
							set_event_par_arr(note_id, EVENT_PAR_CUSTOM, clip_poly + 1, EVENT.TRIGGERED_BY_MF)
							set_event_par_arr(note_id, EVENT_PAR_CUSTOM, OUTSIDE_SOURCE, EVENT.SOURCE)
							set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
							note_callback(note, velocity, note_id)
						end if
						if midi_command[clip_poly, cur_event_poly] = MIDI_COMMAND_CC
							declare cc_num := midi_byte_1[clip_poly, cur_event_poly]
							set_controller(cc_num, midi_byte_2[clip_poly, cur_event_poly])
							wait(1)
							controller_callback(cc_num)
						end if
						inc(cur_event_poly)
					end if

					check_if_it_should_be_playing()
				end while
			end while

			// only turn the button off if you'd let the clip run it's course without clicking it again
			if cb_id[clip_poly] = NI_CALLBACK_ID
				NI_UI_ID -> value := 0
			end if
		end if
	end if

	if NI_UI_ID = get_ui_id(switch_Info)
		switch_info -> hide := HIDE_WHOLE_CONTROL
	end if

	// Articulations
	index := search(articulation_ids, NI_UI_ID)
	if index # -1
		cur_artic := index
		call update_articulation_switches
	end if

	// Speed
	if NI_UI_ID = get_ui_id(slider_speed)
		call update_speed_switches
		call update_speed
	end if

	index := search(speed_ids, NI_UI_ID)
	if index # -1
		slider_speed := index
		call update_speed_switches
		call update_speed
	end if

	// Direction
	if NI_UI_ID = get_ui_id(slider_direction)
		call update_direction_switches
	end if

	index := search(direction_mode_ids, NI_UI_ID)
	if index # -1
		slider_direction := index
		call update_direction_switches
	end if

	// Legato/Quantize
	if NI_UI_ID = get_ui_id(slider_legato)
		call update_legato_switches
	end if

	index := search(legato_ids, NI_UI_ID)
	if index # -1
		slider_legato := index
		call update_legato_switches
	end if

	// Expression
	if NI_UI_ID = get_ui_id(slider_vol)
		insert[0].sfx_wet := map_i_2i_2i_i(slider_vol, 0, 1000000, V2E.volume2(-16000.0), V2E.volume2(6000.0))
	end if

	if NI_UI_ID = get_ui_id(slider_reverb)
		main[0].raum_reverb := slider_reverb
	end if


	// Set keys pressed
	if search(articulation_ids  , NI_UI_ID) # -1 ...
	or search(speed_ids         , NI_UI_ID) # -1 ...
	or search(direction_mode_ids, NI_UI_ID) # -1 ...
	or search(legato_ids        , NI_UI_ID) # -1 ...
	or NI_UI_ID = get_ui_id(slider_speed) ...
	or NI_UI_ID = get_ui_id(slider_direction) ...
	or NI_UI_ID = get_ui_id(slider_legato)
	 	call set_keys_pressed
	end if
end function
