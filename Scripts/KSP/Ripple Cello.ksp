{#pragma save_compiled_source ..\..\Resources\scripts\script.txt}

import "Utilities"
import "Functions/Functions.ksp"

on init
	message("")
	utilities.icb
	engine.ICB()
	tcm.init(1000)
	SET_CONDITION(TCM_LARGE)

	set_key_pressed_support(1)
	set_snapshot_type(3)

	declare dev_mode[1]
	load_array(dev_mode, 2)

	set_listener(NI_SIGNAL_TIMER_MS, 1000000/30) // 30 fps
	set_listener(NI_SIGNAL_TRANSP_START, 1)
	set_listener(NI_SIGNAL_TRANSP_STOP, 1)

	SET_CONDITION(NO_SYS_SCRIPT_PEDAL)

	declare i

	{{ Constants }}
	define UI_WIDTH  := 900
	define UI_HEIGHT := 427
	declare const DOWN := 0
	declare const UP := 1
	declare const NUM_RRS := 4
	declare const MAX_NUM_CHORD_IDS := 1000
	define MAX_NUM_NOTES := 64
	define MAX_RIPPLE_HISTORY := 100
	define NUM_MIDI_PAGES := 2
	define NUM_MIDI_CLIPS := (12 * NUM_MIDI_PAGES)
	define NUM_OPTION_SLIDERS := 4
	define NUM_CTRLS := 7
	define controls := sliders, reverb_type
	define sliders := vol, reverb, options
	define options := speed, direction, legato, releaseSamples


	macro declare_control_constant(#ctrl#)
		declare const control.#ctrl# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_control_constant) on controls
	END_INC

	{{ Event pars }}
	macro declare_event_par(#par#)
		declare custom_event_#par#[1000000]
		property event.#par#
			function get(id) -> result
				result := custom_event_#par#[id mod 1000000]
			end function
		
			function set(id, value)
				custom_event_#par#[id mod 1000000] := value
			end function
		end property
	end macro

	define CUSTOM_EVENT_PARS := ...
	source                            , ...
	note                              , ...
	velocity                          , ...
	low_note                          , ...
	high_note                         , ...
	origin_note                       , ...
	dest_note                         , ...
	first_note                        , ...
	second_note                       , ...
	row                               , ...
	direction                         , ...
	artic                             , ...
	voice                             , ...
	note_off_timestamp                , ...
	release_length                    , ...
	release_sample_length             , ...
	release_note                      , ...
	release_triggered                 , ...
	release_dynamic                   , ...
	brightness_on_release             , ...
	waiting_to_trigger_release_sample , ...
	prev_rec_time_pos_in_ripple       , ...
	releasing                         , ...
	dest_note_released                , ...
	start_note_released               , ...
	triggered_by_mf                   , ...
	preview_being_stopped             , ...
	type

	literate_macro(declare_event_par) on CUSTOM_EVENT_PARS

	define RELEASE_SAMPLE_TYPE := 1
	declare const RECORDED_DURATION_QUARTER := 545455
	declare const RECORDED_DURATION_EIGHTH := 272727
	declare const MAX_INTERVAL := 5
	declare const MIN_BRIGHTNESS := 24
	define CLIP_MARGIN := 4

	// list !ir_paths
	// 	get_folder(GET_FOLDER_FACTORY_DIR) & "/Presets/Effects/Convolution/9 Medium Rooms/IR Samples/SoftnBright.wav"
	// 	get_folder(GET_FOLDER_FACTORY_DIR) & "/Presets/Effects/Convolution/10 Big Rooms/IR Samples/Masterverb Hall.wav"
	// 	get_folder(GET_FOLDER_FACTORY_DIR) & "/Presets/Effects/Convolution/10 Big Rooms/IR Samples/ndb_cathedral_ir_32bit.wav"
	// end list

	{{ Options constants }}
	// Speed
	define NUM_speedModes := 5
	define speedModes := halfSpeed, slowTripletSpeed, fullSpeed, fastTripletSpeed, doubleSpeed
	declare !speed_texts[] := ("Half", "Triplet", "Original", "Triplet", "Double")
	macro declare_speed_mode_constants(#name#)
		declare const speedMode.#name# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_speed_mode_constants) on speedModes
	END_INC
	declare ?speeds[NUM_speedModes]
	START_INC(N, 0, 1)
		speeds[N] := 2.0
		speeds[N] := 1.5
		speeds[N] := 1.0
		speeds[N] := 0.75
		speeds[N] := 0.5
	END_INC

	// Articulation
	define NUM_artics := 3
	define artics := quarters, eighths, sixteenths
	declare !articulation_texts[] := ("Quarters", "Eighths", "Sixteenths")
	macro declare_artic_constants(#name#)
		declare const artic.#name# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_artic_constants) on artics
	END_INC

	// Direction
	define NUM_directionModes := 3
	define directionModes := down, asPlayed, up
	declare !direction_texts[] := ("Down", "As Played", "Up")
	macro declare_direction_mode_constants(#name#)
		declare const directionMode.#name# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_direction_mode_constants) on directionModes
	END_INC

	// Legato
	define NUM_legatoModes := 4
	define legatoModes := noLegato, syncToPitch, syncToRipple, syncToSwell
	declare !legato_texts[] := ("Off", "Sync to Pitch", "Sync to Ripple", "Sync to Swell")
	macro declare_legatoMode_constants(#name#)
		declare const legatoMode.#name# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_legatoMode_constants) on legatoModes
	END_INC

	// Release samples
	define NUM_releaseSampleModes := 3
	define releaseSampleModes := noReleaseSample, softRelease, loudRelease
	declare !releaseSamples_texts[] := ("Off", "Soft", "Loud")
	macro declare_release_sample_mode_constants(#name#)
		declare const releaseSampleMode.#name# := N
	end macro
	START_INC(N, 0, 1)
		literate_macro(declare_release_sample_mode_constants) on releaseSampleModes
	END_INC

	//
	declare !option_texts[NUM_CTRLS, 10]
	declare !option_texts_shortened[NUM_CTRLS, 10]
	macro consolidate_option_texts(#ctrl#)
		for i := 0 to num_elements(#ctrl#_texts) - 1
			option_texts[control.#ctrl#, i] := #ctrl#_texts[i]
		end for
	end macro
	literate_macro(consolidate_option_texts) on options

	copy_array(_option_texts, _option_texts_shortened)
	START_INC(N, 0, 1)
		option_texts_shortened[control.legato, N] := "Off"
		option_texts_shortened[control.legato, N] := "Pitch"
		option_texts_shortened[control.legato, N] := "Ripple"
		option_texts_shortened[control.legato, N] := "Swell"
	END_INC

	//
	declare release_group[NUM_artics]
	release_group[artic.quarters]   := find_group("quarters releases")
	release_group[artic.eighths]    := find_group("eighths releases")
	release_group[artic.sixteenths] := find_group("eighths releases")

	{{ Keyswitch constants }}
	declare const LOWEST_KEY  := 36
	declare const HIGHEST_KEY := 72
	declare articulation_keyswitches[NUM_artics]               := (29, 31, 33)
	declare speed_keyswitches[NUM_speedModes]                  := (72+5, 72+7, 72+9, 72+11, 72+12)
	declare direction_keyswitches[NUM_directionModes]          := (72+14, 72+16, 72+17)
	declare legato_keyswitches[NUM_legatoModes]                := (72+19, 72+21, 72+23, 72+24)
	declare release_sample_keyswitches[NUM_releaseSampleModes] := (72+26, 72+28, 72+29)
	declare release_trigger_keyswitches[2]                     := (24, 108)
		
	// Formatted for Reascript:
	// articulation_keyswitches   = {29, 31, 33}
	// speed_keyswitches          = {72+5, 72+7, 72+9, 72+11, 72+12}
	// direction_keyswitches      = {72+14, 72+16, 72+17}
	// legato_keyswitches         = {72+19, 72+21, 72+23, 72+24}
	// release_sample_keyswitches = {72+26, 72+28}

	// Fill the all_keyswitches array with all the other keyswitch arrays
	declare all_keyswitches[64]
	declare total_num_keyswitches
	for i := 0 to NUM_artics - 1
		all_keyswitches[total_num_keyswitches] := articulation_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_speedModes - 1
		all_keyswitches[total_num_keyswitches] := speed_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_directionModes - 1
		all_keyswitches[total_num_keyswitches] := direction_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_legatoModes - 1
		all_keyswitches[total_num_keyswitches] := legato_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_releaseSampleModes - 1
		all_keyswitches[total_num_keyswitches] := release_sample_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	

	{{ Length Constants }}
	declare rec_time_sample_lengths[NUM_artics]
	rec_time_sample_lengths[artic.quarters]   := RECORDED_DURATION_QUARTER * 16
	rec_time_sample_lengths[artic.eighths]    := RECORDED_DURATION_QUARTER * 8
	rec_time_sample_lengths[artic.sixteenths] := RECORDED_DURATION_QUARTER * 8

	declare rec_time_ripple_lengths[NUM_artics]
	rec_time_ripple_lengths[artic.quarters]   := RECORDED_DURATION_QUARTER * 2
	rec_time_ripple_lengths[artic.eighths]    := RECORDED_DURATION_QUARTER
	rec_time_ripple_lengths[artic.sixteenths] := RECORDED_DURATION_QUARTER

	declare ripple_length_ticks[NUM_artics]
	ripple_length_ticks[artic.quarters]   := 960*2
	ripple_length_ticks[artic.eighths]    := 960
	ripple_length_ticks[artic.sixteenths] := 960

	declare sample_length_ticks[NUM_artics]
	sample_length_ticks[artic.quarters]   := 960 * 16
	sample_length_ticks[artic.eighths]    := 960 * 8
	sample_length_ticks[artic.sixteenths] := 960 * 8

	declare pitch_fractions[NUM_artics]
	pitch_fractions[artic.quarters]   := 2
	pitch_fractions[artic.eighths]    := 2
	pitch_fractions[artic.sixteenths] := 4

	{{ Variables }}
	declare ~db
	declare ~vol
	declare _
	declare timestamp_version_shown
	declare num_active_ripples
	declare num_keys_pressed
	declare key_active[128]
	declare key_down[128]
	declare key_released[128]
	declare rls_note_ids[128]
	fill(key_released, 1)
	declare notes_to_release[1000]
	declare voices_to_release[1000]
	declare num_notes_to_release
	declare num_ripple_voices[128]
	declare note_used_by_ripple[128]
	declare key_timestamp[128]
	declare key_history[100]
	declare ripple_id_history[MAX_RIPPLE_HISTORY]
	declare direction
	declare row
	declare first_ripple_timestamp
	declare cur_midi_page
	declare read cur_artic
	declare all_keys_released := 1
	declare velo[128]
	declare event_ids[128]
	declare ctrl_ids[NUM_CTRLS]
	declare recent_release_trigger_key := release_trigger_keyswitches[0]

	// Fading graphics
	declare ~midiInstructions_opacity := 0.0
	declare ~midiCover_opacity := 0.0
	declare ~smoothed_midiInstructions_opacity
	declare ~smoothed_midiCover_opacity

	// Midi
	declare midi_event_id[NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_command [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_pos     [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_byte_1  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_byte_2  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_length  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare clip_length  [NUM_MIDI_CLIPS]
	declare clip_loop_enabled  [NUM_MIDI_CLIPS]
	declare num_midi_events[NUM_MIDI_CLIPS]
	declare num_midi_notes[NUM_MIDI_CLIPS]
	declare num_midi_ccs[NUM_MIDI_CLIPS]
	declare time_started[NUM_MIDI_CLIPS]
	declare cur_event[NUM_MIDI_CLIPS]
    declare playing[NUM_MIDI_CLIPS]
    declare looping[NUM_MIDI_CLIPS]
    declare midi_file_pos_ticks[NUM_MIDI_CLIPS]
	declare cb_id[NUM_MIDI_CLIPS]

	{{ Iterators }}
	declare hist_i
	declare voice_i
	declare par_i
	declare key_i
	declare ripple_i
	declare b
	declare g
	declare v
	declare r
	declare k
	declare n
	declare e
	declare c
	declare event_i
	declare other_event_i
	declare row_i
	declare vel_i
	declare clip_i

	{{ MIDI }}
	mf_reset()
	define MF_BUFFER_SIZE := 1000
	mf_set_buffer_size(MF_BUFFER_SIZE)
	mf_set_num_export_areas(NUM_MIDI_CLIPS + 1)
	// declare ui_label midi_clip[NUM_MIDI_CLIPS](2,2)
	mf_insert_file(get_folder(GET_FOLDER_PATCH_DIR) & "/../Data/midi.mid", 0, 0, 0)

	// Insert midi data into arrays to be played back
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		// Notes
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_NOTE_ON
				midi_event_id[clip_i, num_midi_events[clip_i]] := mf_get_id()
				midi_command [clip_i, num_midi_events[clip_i]] := mf_get_command()
				midi_pos     [clip_i, num_midi_events[clip_i]] := mf_get_pos()
				midi_byte_1  [clip_i, num_midi_events[clip_i]] := mf_get_byte_one()
				midi_byte_2  [clip_i, num_midi_events[clip_i]] := mf_get_byte_two()
				midi_length  [clip_i, num_midi_events[clip_i]] := mf_get_note_length()
				inc(num_midi_events[clip_i])
				inc(num_midi_notes[clip_i])
			end if
			mf_get_next(clip_i)
		end while

		// Insert pedal CC's at the correct times
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC and mf_get_byte_one() = 64
				declare cc_inserted
				cc_inserted := 0
				for event_i := 0 to num_midi_events[clip_i] - 1
					if cc_inserted = 0
						// Find which events to insert this CC between
						declare insert_index
						insert_index := -1

						// If it comes before the first event
						if event_i = 0
							if mf_get_pos() < midi_pos[clip_i, 0]
								insert_index := 0
								// message("inserted before the first event")
							end if
						end if

						// If it comes sandwiched between two events
						if in_range(event_i, 1, num_midi_events[clip_i] - 2)
							if mf_get_pos() > midi_pos[clip_i, event_i] and mf_get_pos() < midi_pos[clip_i, event_i + 1]
								insert_index := event_i + 1
							end if
						end if

						// If it comes after the last event
						if event_i = num_midi_events[clip_i] - 1
							if mf_get_pos() > midi_pos[clip_i, num_midi_events[clip_i] - 1]
								insert_index := num_midi_events[clip_i]
							end if
						end if

						// If it's right on another event
						if mf_get_pos() = midi_pos[clip_i, event_i]
							insert_index := event_i
							// message("right on another event: " & insert_index)
						end if

						if insert_index # -1
							cc_inserted := 1							

							// Move all following events back one slot
							for other_event_i := MF_BUFFER_SIZE - 1 downto insert_index + 1
								midi_event_id[clip_i, other_event_i] := midi_event_id[clip_i, other_event_i - 1]
								midi_command [clip_i, other_event_i] := midi_command [clip_i, other_event_i - 1]
								midi_pos     [clip_i, other_event_i] := midi_pos     [clip_i, other_event_i - 1]
								midi_byte_1  [clip_i, other_event_i] := midi_byte_1  [clip_i, other_event_i - 1]
								midi_byte_2  [clip_i, other_event_i] := midi_byte_2  [clip_i, other_event_i - 1]
								midi_length  [clip_i, other_event_i] := midi_length  [clip_i, other_event_i - 1]
							end for

							// Add CC
							midi_event_id[clip_i, insert_index] := mf_get_id()
							midi_command [clip_i, insert_index] := mf_get_command()
							midi_pos     [clip_i, insert_index] := mf_get_pos()
							midi_byte_1  [clip_i, insert_index] := mf_get_byte_one()
							midi_byte_2  [clip_i, insert_index] := mf_get_byte_two()
						end if
					end if
				end for
				inc(num_midi_events[clip_i])
				inc(num_midi_ccs[clip_i])
			end if
			mf_get_next(clip_i)
		end while
	end for

	// Find clip lengths
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC
				if mf_get_byte_one() = 103
					clip_length[clip_i] := mf_get_pos()
					if mf_get_byte_two() = 127
						clip_loop_enabled[clip_i] := 1
					else
						clip_loop_enabled[clip_i] := 0
					end if
					// mf_remove_event(mf_get_id()) // clean up
				end if
			end if
			mf_get_next(clip_i)
		end while
	end for

	{{ UI }}
	import "F2K/UI Code.ksp"
	set_control_par_str(INST_ICON_ID, CONTROL_PAR_PICTURE, "insticon")

	label_version -> hide := HIDE_WHOLE_CONTROL

	// Midi page
	declare panel_midiPg[NUM_MIDI_PAGES]
	declare switch_midiPgChooser[NUM_MIDI_PAGES]
	macro write_midiPg_ui_id_to_array(#i#)
		panel_midiPg[#i#] := get_ui_id(panel_midiPg#i#)
		switch_midiPgChooser[#i#] := get_ui_id(switch_midiPgChooser#i#)
	end macro
	iterate_macro(write_midiPg_ui_id_to_array) := 0 to NUM_MIDI_PAGES - 1

	// Need to initialize midi page chooser switches because F2K makes them persistent
	for i := 0 to NUM_MIDI_PAGES - 1
		switch_midiPgChooser[i] -> value := 0
	end for
	switch_midiPgChooser[0] -> value := 1

	declare ui_slider mf_cursor[NUM_MIDI_CLIPS](0, 1000)
	declare midi_clip_panel_id[NUM_MIDI_CLIPS]
	declare midi_clip_id[NUM_MIDI_CLIPS]
	declare midi_clip_dnd_id[NUM_MIDI_CLIPS]
	declare midi_clip_preview_id[NUM_MIDI_CLIPS]
	macro put_midi_clip_ui_controls_into_arrays(#i#)
		midi_clip_panel_id[#i#]   := get_ui_id(panel_clip#i#)
		midi_clip_id[#i#]         := get_ui_id(label_clip#i#)
		midi_clip_dnd_id[#i#]     := get_ui_id(label_clip_dnd#i#)
		midi_clip_preview_id[#i#] := get_ui_id(switch_preview#i#)
	end macro
	iterate_macro(put_midi_clip_ui_controls_into_arrays) := 0 to NUM_MIDI_CLIPS - 1

	for i := 0 to NUM_MIDI_CLIPS - 1
		mf_set_export_area("Ripple Cello", -1, -1, i, i)
		mf_copy_export_area(i + 1)
		midi_clip_dnd_id[i] -> midi_export_area_idx := i + 1
		midi_clip_dnd_id[i] -> dnd_behaviour := 1
		midi_clip_preview_id[i] -> z_layer := 1
		midi_clip_preview_id[i] -> value := 0
		mf_cursor[i] -> picture := "mf_cursor"
		mf_cursor[i] -> hide := HIDE_WHOLE_CONTROL
		mf_cursor[i] -> parent_panel := midi_clip_panel_id[i]
		// set_bounds(mf_cursor[i], 5, 0, 1, midi_clip_id[i] -> height)
		set_bounds(mf_cursor[i], 0, 0)
	end for

	button_showMidi := 0
	update_midi_visibility()


	// Z layers

	// putting panel_midi on z_layer 1 would mess up the hover states. 
	// So instead, I'm just hiding all z_layer=1 controls whenever I show panel_midi
	panel_midi -> z_layer := 0

	switch_generalInfoDisp        -> hide := HIDE_WHOLE_CONTROL
	switch_articulationsInfoDisp  -> hide := HIDE_WHOLE_CONTROL
	switch_optionsInfoDisp        -> hide := HIDE_WHOLE_CONTROL
	switch_speedInfoDisp          -> hide := HIDE_WHOLE_CONTROL
	switch_directionInfoDisp      -> hide := HIDE_WHOLE_CONTROL
	switch_legatoInfoDisp         -> hide := HIDE_WHOLE_CONTROL
	switch_releaseSamplesInfoDisp -> hide := HIDE_WHOLE_CONTROL


	switch_generalInfoDisp        -> z_layer := 1
	switch_articulationsInfoDisp  -> z_layer := 1
	switch_optionsInfoDisp        -> z_layer := 1
	switch_speedInfoDisp          -> z_layer := 1
	switch_directionInfoDisp      -> z_layer := 1
	switch_legatoInfoDisp         -> z_layer := 1
	switch_releaseSamplesInfoDisp -> z_layer := 1

	panel_midiPgChooser   -> z_layer := 1
	switch_midiPgChooser0 -> z_layer := 1
	switch_midiPgChooser1 -> z_layer := 1

	panel_articulations  -> z_layer := 1
	panel_fx             -> z_layer := 1
	panel_speed          -> z_layer := 1
	panel_direction      -> z_layer := 1
	panel_legato         -> z_layer := 1
	panel_releaseSamples -> z_layer := 1



	declare key_ids[128]
	macro assign_key_id(#i#)
		key_ids[#i# + LOWEST_KEY]        := get_ui_id(label_oct0.note#i#)
		key_ids[#i# + LOWEST_KEY + 12]   := get_ui_id(label_oct1.note#i#)
		key_ids[#i# + LOWEST_KEY + 12*2] := get_ui_id(label_oct2.note#i#)
	end macro
	iterate_macro(assign_key_id) := 0 to 11
	key_ids[72] := get_ui_id(label_oct2.note12)

	for key_i := LOWEST_KEY to HIGHEST_KEY
		key_ids[key_i] -> value := 0
	end for

	define NUM_REVERB_PRESETS := 3
	define NUM_PRESET_PARS := 8
	declare !reverb_preset_names[NUM_REVERB_PRESETS] := ("Small", "Medium", "Large")
	declare read reverb_preset[NUM_REVERB_PRESETS, NUM_PRESET_PARS]
	for i := 0 to NUM_REVERB_PRESETS - 1
		add_menu_item(menu_reverb, reverb_preset_names[i], i)
	end for
	add_menu_item(menu_reverb, "save preset", NUM_REVERB_PRESETS)
	declare read prev_reverb := menu_reverb
	if dev_mode[0] = 0
		set_menu_item_visibility(get_ui_id(menu_reverb), NUM_REVERB_PRESETS, 0)
	end if
	switch_reverbToggle -> text_alignment := 0
	switch_reverbToggle -> text := "REVERB"
	label_vol -> font_type := get_font_id("Khula Bold Size 11 on")
	switch_reverbToggle -> font_type             := get_font_id("Khula Bold Size 11 off")
	switch_reverbToggle -> font_type_on          := get_font_id("Khula Bold Size 11 on")
	switch_reverbToggle -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
	switch_reverbToggle -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
	switch_reverbToggle -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
	switch_reverbToggle -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
	switch_reverbToggle -> disable_text_shifting := 1
	switch_reverbToggle -> automation_name := 0

	// Articulations
	declare articulation_ids[NUM_artics]
	macro assign_articulation_id(#artic#)
		articulation_ids[artic.#artic#] := get_ui_id(switch_#artic#)
	end macro
	literate_macro(assign_articulation_id) on artics
	for i := 0 to NUM_artics - 1
		articulation_ids[i] -> allow_automation := 0
	end for

	// Speed
	declare speed_ids[NUM_speedModes]
	macro assign_speed_mode_id(#mode#)
		speed_ids[speedMode.#mode#] := get_ui_id(switch_#mode#)
	end macro
	literate_macro(assign_speed_mode_id) on speedModes
	for i := 0 to num_elements(speed_ids) - 1
		speed_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		speed_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		speed_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		speed_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		speed_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		speed_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		speed_ids[i] -> text := speed_texts[i]
		speed_ids[i] -> width := speed_ids[i] -> width + 14
	end for

	// Direction
	declare direction_ids[NUM_directionModes]
	macro assign_direction_mode_ids(#mode#)
		direction_ids[directionMode.#mode#] := get_ui_id(switch_#mode#)
	end macro
	literate_macro(assign_direction_mode_ids) on directionModes
	for i := 0 to num_elements(direction_ids) - 1
		direction_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		direction_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		direction_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		direction_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		direction_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		direction_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		direction_ids[i] -> text := direction_texts[i]
	end for
	switch_down     -> width := switch_down     -> width + 13
	switch_asPlayed -> width := switch_asPlayed -> width + 19
	switch_up       -> width := switch_up       -> width + 7

	// Legato/Quantize
	declare legato_ids[NUM_legatoModes]
	macro assign_legato_mode_ids(#mode#)
		legato_ids[legatoMode.#mode#] := get_ui_id(switch_#mode#)
	end macro
	literate_macro(assign_legato_mode_ids) on legatoModes
	for i := 0 to num_elements(legato_ids) - 1
		legato_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		legato_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		legato_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		legato_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		legato_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		legato_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		legato_ids[i] -> text := option_texts_shortened[control.legato, i]
	end for

	// Release Mode
	declare releaseSamples_ids[NUM_releaseSampleModes]
	macro assign_releaseSample_mode_ids(#mode#)
		releaseSamples_ids[releaseSampleMode.#mode#] := get_ui_id(switch_#mode#)
	end macro
	literate_macro(assign_releaseSample_mode_ids) on releaseSampleModes
	for i := 0 to num_elements(releaseSamples_ids) - 1
		releaseSamples_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		releaseSamples_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		releaseSamples_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		releaseSamples_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		releaseSamples_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		releaseSamples_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		releaseSamples_ids[i] -> text := releaseSamples_texts[i]
	end for
	switch_noReleaseSample  -> width := switch_noReleaseSample  -> width + 14
	switch_softRelease      -> width := switch_softRelease      -> width + 14
	switch_loudRelease      -> width := switch_loudRelease      -> width + 14

	switch_releaseTrigger -> allow_automation := 0


	// Options misc setting things up
	define OPTIONS_MOUSE_BEHAVIOR := 2000
	slider_speed          -> mouse_behaviour := OPTIONS_MOUSE_BEHAVIOR
	slider_direction      -> mouse_behaviour := OPTIONS_MOUSE_BEHAVIOR
	slider_legato         -> mouse_behaviour := OPTIONS_MOUSE_BEHAVIOR
	slider_releaseSamples -> mouse_behaviour := OPTIONS_MOUSE_BEHAVIOR

	macro assign_ctrl_ids(#ctrl#)
		ctrl_ids[control.#ctrl#] := get_ui_id(slider_#ctrl#)
	end macro
	literate_macro(assign_ctrl_ids) on sliders

	slider_speed     -> default := 2
	slider_direction -> default := 1
	slider_legato    -> default := 0

	slider_vol -> default := 500000
	slider_reverb -> default := 500000

	menu_reverb -> textpos_y := 100

	// Old

	set_voice_limit(NI_VL_TMPRO_STANDARD, 32)
	declare ui_slider ripple[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple) - 1
		// ripple[i] -> picture := "ripple 0"
		ripple[i] -> z_layer := -1
		ripple[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	declare ui_slider ripple_swell[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple_swell) - 1
		// ripple_swell[i] -> picture := "ripple_swell 0"
		ripple_swell[i] -> z_layer := -1
		ripple_swell[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	{{ Automation }}
	START_INC (N, 0, 1)
		slider_vol            -> automation_id := N
		slider_vol            -> automation_name := "VOL"
		slider_reverb         -> automation_id := N
		slider_reverb         -> automation_name := "Reverb"
		slider_speed          -> automation_id := N
		slider_speed          -> automation_name := "Speed"
		slider_direction      -> automation_id := N
		slider_direction      -> automation_name := "Direction"
		slider_legato         -> automation_id := N
		slider_legato         -> automation_name := "Legato/Quantize"
		slider_releaseSamples -> automation_id := N
		slider_releaseSamples -> automation_name := "Release Samples"
	END_INC

	// DEV
	declare @siln2 := "START_EVENTS_INTEGERS_ENGINE"
	group[artic.quarters].speed   := V2E_speed(18*2)
	group[artic.eighths].speed    := V2E_speed(18)
	group[artic.sixteenths].speed := V2E_speed(18)
	group[find_group("quarters releases")].speed := V2E_speed(12)
	group[find_group("eighths releases")].speed := V2E_speed(12)


end on

on persistence_changed
	persistence_changed_callback(_)
end on
function persistence_changed_callback(_)
	call set_key_colors_and_types_and_names
	call set_keys_pressed
	call set_reverb_menu_checkmark
	call update_reverb_slider_picture
	for i := 0 to NUM_CTRLS - 1
		update_nks_label(i)
		update_engine_pars(i)
	end for
end function

on note
	event[EVENT_ID].source := OUTSIDE_SOURCE
	set_event_par_arr(EVENT_ID, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
	note_callback(EVENT_NOTE, EVENT_VELOCITY, EVENT_ID)
end on
function note_callback(note, velocity, event_id)
	set_key_pressed(note, 1)
	key_down[note] := 1
	velo[note] := velocity

	// Keyswitches
	declare ks_index := search(articulation_keyswitches, note)
	if ks_index # -1
		cur_artic := ks_index
		call update_articulation_switches
	end if

	ks_index := search(speed_keyswitches, note)
	if ks_index # -1
		slider_speed := ks_index
		call update_speed_switches
		update_engine_pars(control.speed)
		update_nks_label(control.speed)
	end if

	ks_index := search(direction_keyswitches, note)
	if ks_index # -1
		slider_direction := ks_index
		call update_direction_switches
		update_nks_label(control.direction)
	end if

	ks_index := search(legato_keyswitches, note)
	if ks_index # -1
		slider_legato := ks_index
		call update_legato_switches
		update_nks_label(control.legato)
	end if

	ks_index := search(release_sample_keyswitches, note)
	if ks_index # -1
		slider_releaseSamples := ks_index
		call update_releaseSamples_switches
		update_nks_label(control.releaseSamples)
	end if

	ks_index := search(release_trigger_keyswitches, note)
	if ks_index # -1
		switch_releaseTrigger := 1
		recent_release_trigger_key := note
		call trigger_release_samples_for_all_ripples
	end if

	if search(all_keyswitches, note) # -1
		call set_keys_pressed
	end if

	// Playable range
	if in_range(note, LOWEST_KEY, HIGHEST_KEY)
		// Key arrays
		key_active   [note] := 1
		key_timestamp[note] := ENGINE_UPTIME
		velo         [note] := velocity

		// UI keyboard
		key_ids[note] -> picture_state := 1

		// Keys history
		for key_i := num_elements(key_history) - 2 downto 0
			key_history[key_i + 1] := key_history[key_i]
		end for
		key_history[0] := note

		call count_keys_pressed
		if num_keys_pressed > 1
			declare notes[MAX_NUM_NOTES]
			declare intervals[MAX_NUM_NOTES]
			declare played_notes[MAX_NUM_NOTES]
			declare played_intervals[MAX_NUM_NOTES]
			define MAX_NUM_RIPPLES_PER_NOTE := 12
			declare notes[MAX_NUM_RIPPLES_PER_NOTE]
			declare intervals[MAX_NUM_RIPPLES_PER_NOTE]
			declare num_ripples := 0

			// Fill neighbor arrays, to be analyzed later
			declare closest_neighbor := -1
			declare closest_neighbor_interval := 12
			declare neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare lower_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare upper_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			fill(neighbor, 0)
			fill(lower_neighbor, 0)
			fill(upper_neighbor, 0)
			declare num_neighbors := 0
			declare num_lower_neighbors := 0
			declare num_upper_neighbors := 0

			for i := 1 to MAX_INTERVAL
				// Look below and above
				declare dir
				for dir := 0 to 1
					declare sign := dir*2-1
					declare other_note := note + i*sign
					if key_down[other_note] = 1
						neighbor[num_neighbors] := other_note
						inc(num_neighbors)
						if other_note < note
							lower_neighbor[num_lower_neighbors] := other_note
							inc(num_lower_neighbors)
						end if
						if other_note > note
							upper_neighbor[num_upper_neighbors] := other_note
							inc(num_upper_neighbors)
						end if
					end if
				end for
			end for

			if lower_neighbor[0] # 0 and upper_neighbor[0] # 0
				declare lower_neighbor_time_held := ENGINE_UPTIME - key_timestamp[lower_neighbor[0]]
				declare upper_neighbor_time_held := ENGINE_UPTIME - key_timestamp[upper_neighbor[0]]
				declare make_ripples_to_both_adjacent_neighbors
				if abs(upper_neighbor_time_held - lower_neighbor_time_held) < 50
					make_ripples_to_both_adjacent_neighbors := 1
				else
					make_ripples_to_both_adjacent_neighbors := 0
				end if
				if slider_direction = directionMode.UP or slider_direction = directionMode.DOWN
					make_ripples_to_both_adjacent_neighbors := 1
				end if

				if make_ripples_to_both_adjacent_neighbors = 1
					notes[0] := lower_neighbor[0]
					intervals[0] := note - lower_neighbor[0]
					notes[1] := upper_neighbor[0]
					intervals[1] := note - upper_neighbor[0]
					num_ripples := 2
				else if make_ripples_to_both_adjacent_neighbors = 0
					if search(key_history, lower_neighbor[0]) < search(key_history, upper_neighbor[0])
						// lower neighbor happened more recently
						notes[0] := lower_neighbor[0]
						intervals[0] := note - lower_neighbor[0]
					else
						// upper neighbor happened more recently
						notes[0] := upper_neighbor[0]
						intervals[0] := note - upper_neighbor[0]
					end if
					num_ripples := 1
				end if
			else
				// Find ripple to play from history
				notes[0]     := key_history[1]
				intervals[0] := key_history[0] - key_history[1]
				num_ripples := 1

				if abs(intervals[0]) > MAX_INTERVAL
					if num_neighbors > 0
						// If ripples can't be made using history, use closest neighbor, up or down
						notes[0] := neighbor[0]
						intervals[0] := note - neighbor[0]
						num_ripples := 1
					else 
						// If that doesn't work, then don't make any ripples at all
						fill(notes, 0)
						fill(intervals, 0)
						num_ripples := 0
					end if
				end if
			end if

			copy_array(notes, played_notes)
			copy_array(intervals, played_intervals)
			fill(note_used_by_ripple, 0)
			declare ripple_i
			for ripple_i := 0 to num_ripples - 1
				// Swap notes and intervals to change directions
				if slider_direction = directionMode.UP
					if intervals[ripple_i] < 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				else if slider_direction = directionMode.DOWN
					if intervals[ripple_i] > 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				end if

				// Get low and high notes
				if intervals[ripple_i] < 0
					declare low_note := notes[ripple_i] + intervals[ripple_i]
					declare high_note := notes[ripple_i]
				else
					low_note := notes[ripple_i]
					high_note := notes[ripple_i] + intervals[ripple_i]
				end if

				// Direction
				if intervals[ripple_i] > 0
					direction := UP
				else
					direction := DOWN
				end if

				// Make sure this particular interval and direction isn't already being played
				declare already_playing := 0
				for r := 0 to MAX_RIPPLE_HISTORY - 1
					if ripple_id_history[r] # 0
						if event[ripple_id_history[r]].low_note = low_note    and key_released[low_note]  = 0 ...
						and event[ripple_id_history[r]].high_note = high_note and key_released[high_note] = 0 ...
						and event[ripple_id_history[r]].high_note = high_note ...
						and event[ripple_id_history[r]].direction = direction ...
						and event[ripple_id_history[r]].releasing = 0
							already_playing := 1
						end if
					end if
				end for

				key_released[low_note] := 0
				key_released[high_note] := 0

				if already_playing = 0
					declare offset_real_time
					declare do_legato := 0

					call count_active_ripples
					if num_active_ripples > 0
						do_legato := 1
					end if

					if all_keys_released = 1
						do_legato := 0
					else
						do_legato := 1
					end if
					all_keys_released := 0

					if do_legato = 0
						first_ripple_timestamp := ENGINE_UPTIME
						declare real_legato_time := 0
						offset_real_time := 0
					else
						// declare first_ripple := find_first_active_ripple()
						real_legato_time := (ENGINE_UPTIME - first_ripple_timestamp) * 1000
						real_legato_time := int(float(real_legato_time) / speeds[slider_speed])
						select slider_legato
							case legatoMode.syncToPitch
								real_legato_time := real_legato_time + ticks_to_ms(5) // For when you add a ripple using grid-snapped notes.
								offset_real_time := real_legato_time mod ticks_to_ms(ripple_length_ticks[cur_artic] / pitch_fractions[cur_artic])
							case legatoMode.syncToRipple
								offset_real_time := real_legato_time mod ticks_to_ms(ripple_length_ticks[cur_artic])
							case legatoMode.syncToSwell
								offset_real_time := real_legato_time mod ticks_to_ms(sample_length_ticks[cur_artic])
						end select
					end if
					declare offset_rec_time := map_i_2i_2i_i(offset_real_time, 0, ticks_to_ms(sample_length_ticks[cur_artic]), 0, rec_time_sample_lengths[cur_artic])
					declare note_id := play_note(notes[ripple_i], 64 + intervals[ripple_i], offset_rec_time, 0)
					declare volume  := map_i_2i_2i_i(velocity, 1, 127, -12000, 3000)
					if offset_rec_time = 0
						// tmpro causes a bit of a bump sometimes. This hides that.
						fade_in(note_id, DURATION_SIXTEENTH)
					end if
					change_vol(note_id, volume, CHANGE_ABSOLUTE)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, cur_artic)
					event[note_id].artic := cur_artic
					event[note_id].note := note
					event[note_id].low_note := low_note
					event[note_id].high_note := high_note
					event[note_id].origin_note := notes[ripple_i]
					event[note_id].dest_note := notes[ripple_i] + intervals[ripple_i]
					event[note_id].first_note := played_notes[ripple_i]
					event[note_id].second_note := played_notes[ripple_i] + played_intervals[ripple_i]
					event[note_id].velocity := velocity

					if note_used_by_ripple[event[note_id].second_note] = 0
						event[note_id].voice := num_ripple_voices[event[note_id].second_note]
						inc(num_ripple_voices[event[note_id].second_note])
						note_used_by_ripple[event[note_id].second_note] := 1
					else
						event[note_id].voice := num_ripple_voices[event[note_id].second_note] - 1
					end if
					event[note_id].direction := direction
					event[note_id].source := OUTSIDE_SOURCE
					event[note_id].triggered_by_mf := event[event_id].triggered_by_mf

					// Push note id to ripple history
					for r := MAX_RIPPLE_HISTORY - 2 downto 0
						ripple_id_history[r + 1] := ripple_id_history[r]
					end for
					ripple_id_history[0] := note_id

					// Fade in
					if real_legato_time > 0
						declare real_time_pos_in_ripple := (real_legato_time - ticks_to_ms(2)) mod ticks_to_ms(ripple_length_ticks[cur_artic])
						real_time_pos_in_ripple := int(float(real_time_pos_in_ripple) / speeds[slider_speed])
						declare fade_in_time := ticks_to_ms(ripple_length_ticks[cur_artic]) - real_time_pos_in_ripple
						if fade_in_time < 150000
							fade_in_time := 150000
						end if
						fade_in(note_id, fade_in_time)
					end if

				end if
			end for
		end if
	end if
end function


on release
	release_callback(EVENT_NOTE, EVENT_ID)
end on
function release_callback(note, event_id)
	key_released[note] := 1
	key_down[note] := 0
	if search(all_keyswitches, note) = -1
		set_key_pressed(note, 0)
	end if

	if note = release_trigger_keyswitches[0] or note = release_trigger_keyswitches[1]
		switch_releaseTrigger := 0
	end if

	if in_range(note, LOWEST_KEY, HIGHEST_KEY) and event[event_id].source = OUTSIDE_SOURCE
		key_ids[note] -> picture_state := 0

		// move all history
		declare history_index := search_for_note_in_key_history(note)
		if history_index > -1
			for key_i := history_index to num_elements(key_history) - 2
				key_history[key_i] := key_history[key_i + 1]
			end for
		end if
			
		if CC[64] < 10
			key_active[note] := 0
			if num_ripple_voices[note] = 0
				release(note, 0)
			else
				for voice_i := 0 to num_ripple_voices[note] - 1
					release(note, voice_i)
				end for
			end if
			num_ripple_voices[note] := 0
		else
			// fill up array of notes/voices to be released when pedal comes up
			notes_to_release[num_notes_to_release] := note
			voices_to_release[num_notes_to_release] := num_ripple_voices[note] - 1
			inc(num_notes_to_release)
		end if
	end if
end function

function release(note, voice)
	// if voice = -1
	// 	msg(voice)
	// end if

	declare r
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] # 0
			if voice = event[ripple_id_history[r]].voice

				declare artic := event[ripple_id_history[r]].artic

				declare rec_time_pos_in_ripple := ripple_id_history[r] -> play_pos mod rec_time_ripple_lengths[artic]
				declare real_time_pos_in_pulse := map_i_2i_2i_i(rec_time_pos_in_ripple, 0, rec_time_ripple_lengths[artic], 0, ticks_to_ms(ripple_length_ticks[artic]))
				real_time_pos_in_pulse := int(float(real_time_pos_in_pulse) * speeds[slider_speed])
				declare real_time_ripple_length := ticks_to_ms(int(float(ripple_length_ticks[artic]) * speeds[slider_speed]))
				declare time_til_end_of_ripple := (real_time_ripple_length - real_time_pos_in_pulse) / 1000

				if note = event[ripple_id_history[r]].second_note

					// Decide whether to play release sample
					declare play_release_sample
					if slider_releaseSamples = 0
						if key_down[recent_release_trigger_key] = 1
							play_release_sample := 1
						else
							play_release_sample := 0
						end if
					else if slider_releaseSamples > 0
						play_release_sample := 1
					end if

					// Either fade out, or put release sample into queue
					event[ripple_id_history[r]].note_off_timestamp := ENGINE_UPTIME
					if play_release_sample = 0
						event[ripple_id_history[r]].releasing := 1
						declare fade_out_time := time_til_end_of_ripple //+ ticks_to_ms(ripple_length_ticks[artic])
						event[ripple_id_history[r]].release_length := fade_out_time
						// if fade_out_time < DURATION_SIXTEENTH / 8 / 1000
						// 	fade_out_time := ticks_to_ms(ripple_length_ticks[artic] / pitch_fractions[artic]) / 1000
						// end if
						fade_out(ripple_id_history[r], fade_out_time * 1000, STOP_VOICE_AFTER_FADE_OUT)
					else
						event[ripple_id_history[r]].release_dynamic := velo[recent_release_trigger_key] / 64
						event[ripple_id_history[r]].release_triggered := 1
						event[ripple_id_history[r]].waiting_to_trigger_release_sample := 1
					end if
				end if

				// Old:
				// dynamic_release(note)
				// immediate_release(note)
			end if
		end if
	end for

	call count_keys_pressed
	if num_keys_pressed = 0
		all_keys_released := 1
	end if
end function


on controller
	controller_callback(CC_NUM)
end on
function controller_callback(cc_num)
	if cc_num = 64
		declare prev_cc64
		if CC[64] < 10 and prev_cc64 >= 10
			declare i
			for i := 0 to num_notes_to_release - 1
				key_active[notes_to_release[i]] := key_down[notes_to_release[i]]
				release(notes_to_release[i], voices_to_release[i])
			end for
			fill(notes_to_release, 0)
			fill(voices_to_release, 0)
			num_notes_to_release := 0

			// declare key_i
			// for key_i := LOWEST_KEY to HIGHEST_KEY
				// Release most recent voice if the key is up
				// if key_down[key_i] = 0 and key_active[key_i] = 1
				// 	key_active[key_i] := 0
				// 	release(key_i, num_ripple_voices[key_i] - 1)
				// end if

				// Release all other previous voices, no matter what
				// for voice_i := 0 to num_ripple_voices[key_i] - 2
				// 	release(key_i, voice_i)
				// end for


				// set num_ripple_voices
				// num_ripple_voices[key_i] := key_down[key_i]
			// end for
		end if
		prev_cc64 := CC[64]
	end if
end function


on listener
	listener_callback()
end on
function listener_callback
	select NI_SIGNAL_TYPE
		case NI_SIGNAL_TIMER_MS
			call remove_ripple_ids_from_history_after_they_have_faded_out
			call ripple_animations
			// call update_recorded_midi
			call midi_clip_play_cursors
			call info_graphics_animation
			call play_release_samples_when_its_time
			call crossfaded_looping
			call hide_version
		case NI_SIGNAL_TRANSP_START
			first_ripple_timestamp := ENGINE_UPTIME
			stop_ideas_panel()

		case NI_SIGNAL_TRANSP_STOP
			stop_ideas_panel()
	end select
end function


macro stop_ideas_panel
	set_controller(64, 0)
	wait(1)
	for clip_i := 0 to num_elements(midi_clip_preview_id) - 1
		midi_clip_preview_id[clip_i] -> value := 0
		if playing[clip_i] = 1
			get_event_ids(event_ids)
			for e := 0 to num_elements(event_ids) - 1
				if event_ids[e] # 0
					if event[event_ids[e]].triggered_by_mf = clip_i + 1
						event[event_ids[e]].preview_being_stopped := 1 // don't let crossfaded looping fade in a note while this event is trying to be faded out here.
						fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
						if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
							key_ids[event_ids[e] -> note] -> picture_state := 0
							key_down[event_ids[e] -> note] := 0
							key_active[event_ids[e] -> note] := 0
						end if
					end if
				end if
			end for
			playing[clip_i] := 0
			looping[clip_i] := 0
		end if
	end for
end macro

// Show midi
on ui_control(button_showMidi)
	if button_showMidi = 0
		stop_ideas_panel()
	end if
	call update_midi_visibility
end on
on ui_control(switch_closeMidi)
	button_showMidi := 0
	stop_ideas_panel()
	call update_midi_visibility
end on

// Midi page chooser
macro midi_page_chooser_callbacks(#i#)
	on ui_control (switch_midiPgChooser#i#)
		switch_midiPgChooser#i#_callback()
	end on
	function switch_midiPgChooser#i#_callback
		cur_midi_page := #i#
		call update_midi_visibility
		for i := 0 to NUM_MIDI_PAGES - 1
			if i = cur_midi_page
				switch_midiPgChooser[i] -> value := 1
			else
				switch_midiPgChooser[i] -> value := 0
			end if
		end for
	end function
end macro
iterate_macro(midi_page_chooser_callbacks) := 0 to NUM_MIDI_PAGES - 1


// General info
on ui_control(button_generalInfo)
	button_showMidi := 0
	call update_midi_visibility
	if switch_generalInfoDisp -> hide = HIDE_WHOLE_CONTROL
		switch_generalInfoDisp -> hide := HIDE_PART_NOTHING
	else
		switch_generalInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if
end on

on ui_control(switch_generalInfoDisp)
	switch_generalInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Articulations info
on ui_control(button_articulationsInfo)
	switch_articulationsInfoDisp -> hide := HIDE_PART_NOTHING
end on

on ui_control(switch_articulationsInfoDisp)
	switch_articulationsInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Options info
on ui_control(button_optionsInfo)
	button_showMidi := 0
	call update_midi_visibility
	if switch_optionsInfoDisp -> hide = HIDE_WHOLE_CONTROL
		switch_optionsInfoDisp -> hide := HIDE_PART_NOTHING
	else
		switch_optionsInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if
end on

on ui_control(switch_optionsInfoDisp)
	switch_optionsInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Speed info
on ui_control(button_speedInfo)
	switch_speedInfoDisp -> hide := HIDE_PART_NOTHING
end on

on ui_control(switch_speedInfoDisp)
	switch_speedInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Direction info
on ui_control(button_directionInfo)
	switch_directionInfoDisp -> hide := HIDE_PART_NOTHING
end on

on ui_control(switch_directionInfoDisp)
	switch_directionInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Legato info
on ui_control(button_legatoInfo)
	switch_legatoInfoDisp -> hide := HIDE_PART_NOTHING
end on

on ui_control(switch_legatoInfoDisp)
	switch_legatoInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

// Release samples info
on ui_control(button_releaseSamplesInfo)
	switch_releaseSamplesInfoDisp -> hide := HIDE_PART_NOTHING
end on

on ui_control(switch_releaseSamplesInfoDisp)
	switch_releaseSamplesInfoDisp -> hide := HIDE_WHOLE_CONTROL
end on

macro midi_clip_preview_callbacks(#i#)
	on ui_control(switch_preview#i#)
		switch_preview#i#_callback(_)
	end on
	function switch_preview#i#_callback(_)
		set_controller(64, 0)
		wait(1)
		if midi_clip_preview_id[#i#] -> value = 0
			playing[#i#] := 0
			looping[#i#] := 0

			// Stop clicked clip
			get_event_ids(event_ids)
			for e := 0 to num_elements(event_ids) - 1
				if event_ids[e] # 0
					if event[event_ids[e]].triggered_by_mf = #i# + 1
						event[event_ids[e]].preview_being_stopped := 1 // don't let crossfaded looping fade in a note while this event is trying to be faded out here.
						fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
						if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
							key_ids[event_ids[e] -> note] -> picture_state := 0
							key_down[event_ids[e] -> note] := 0
							key_active[event_ids[e] -> note] := 0
						end if
					end if
				end if
			end for

			cb_id[#i#] := NI_CALLBACK_ID
		else
			cb_id[#i#] := NI_CALLBACK_ID

			// Release any other midi notes from other clips
			declare other_clip_i
			for other_clip_i := 0 to num_elements(midi_clip_preview_id) - 1
				if #i# # other_clip_i
					midi_clip_preview_id[other_clip_i] -> value := 0
					if playing[other_clip_i] = 1
						get_event_ids(event_ids)
						for e := 0 to num_elements(event_ids) - 1
							if event_ids[e] # 0
								if event[event_ids[e]].triggered_by_mf = other_clip_i + 1
									event[event_ids[e]].preview_being_stopped := 1 // don't let crossfaded looping fade in a note while this event is trying to be faded out here.
									fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
									if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
										key_ids[event_ids[e] -> note] -> picture_state := 0
										key_down[event_ids[e] -> note] := 0
										key_active[event_ids[e] -> note] := 0
									end if
								end if
							end if
						end for
						playing[other_clip_i] := 0
						looping[other_clip_i] := 0
					end if
				end if
			end for

			//Play
			looping[#i#] := 1
			while looping[#i#] = 1 and cb_id[#i#] = NI_CALLBACK_ID
				if clip_loop_enabled[#i#] = 0
					looping[#i#] := 0
				end if
				if button_showMidi = 0
					looping[#i#] := 0
				end if

				cur_event[#i#] := 0
				
				midi_file_pos_ticks[#i#] := 0
				time_started[#i#] := ENGINE_UPTIME
				call midi_clip_play_cursors

				playing[#i#] := 1
				while playing[#i#] = 1 and cb_id[#i#] = NI_CALLBACK_ID
					if cur_event[#i#] = num_midi_events[#i#]
						declare ticks_until_next_event := clip_length[#i#] - midi_file_pos_ticks[#i#]
					else
						ticks_until_next_event := midi_pos[#i#, cur_event[#i#]] - midi_file_pos_ticks[#i#]
					end if

					if ticks_until_next_event > 0
						wait(ticks_to_ms(ticks_until_next_event))
					end if

					// check_if_it_should_be_playing
					if cur_event[#i#] > num_midi_events[#i#]
						playing[#i#] := 0
					end if
					if button_showMidi = 0
						playing[#i#] := 0
					end if

					if playing[#i#] = 1 and cb_id[#i#] = NI_CALLBACK_ID
						midi_file_pos_ticks[#i#] := midi_file_pos_ticks[#i#] + ticks_until_next_event
						if midi_command[#i#, cur_event[#i#]] = MIDI_COMMAND_NOTE_ON
							declare note     := midi_byte_1[#i#, cur_event[#i#]]
							declare velocity := midi_byte_2[#i#, cur_event[#i#]]
							declare length   := ticks_to_ms(midi_length[#i#, cur_event[#i#]])
							declare note_id  := play_note(note, velocity, 0, length)
							event[note_id].triggered_by_mf := #i# + 1
							event[note_id].source := OUTSIDE_SOURCE
							set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
							note_callback(note, velocity, note_id)
						end if
						if midi_command[#i#, cur_event[#i#]] = MIDI_COMMAND_CC
							declare cc_num := midi_byte_1[#i#, cur_event[#i#]]
							set_controller(cc_num, midi_byte_2[#i#, cur_event[#i#]])
							wait(1)
							controller_callback(cc_num)
						end if
						inc(cur_event[#i#])
					end if

					// check_if_it_should_be_playing
					if cur_event[#i#] > num_midi_events[#i#]
						playing[#i#] := 0
					end if
					if button_showMidi = 0
						playing[#i#] := 0
					end if
				end while
			end while

			// only turn the button off if you'd let the clip run it's course without clicking it again
			if cb_id[#i#] = NI_CALLBACK_ID
				midi_clip_preview_id[#i#] -> value := 0
			end if
		end if
	end function
end macro
iterate_macro(midi_clip_preview_callbacks) := 0 to NUM_MIDI_CLIPS - 1

	
// Articulations
macro articulation_switch_callbacks(#artic#)
	on ui_control (switch_#artic#)
		cur_artic := artic.#artic#
		call update_articulation_switches
		call set_keys_pressed
	end on
end macro
literate_macro(articulation_switch_callbacks) on artics

// Vol
on ui_control(slider_vol)
	update_engine_pars(control.vol)
	update_nks_label(control.vol)
	call set_keys_pressed
end on

// Reverb
on ui_control(menu_reverb)
	call set_reverb_menu_checkmark
	prev_reverb := menu_reverb
	call set_keys_pressed
	update_engine_pars(control.reverb_type)
end on

on ui_control (switch_reverbToggle)
	call update_reverb_slider_picture
	call update_reverb_send_levels
end on


on ui_control(slider_reverb)
	slider_reverb_callback()
end on
function slider_reverb_callback
	update_engine_pars(control.reverb)
	update_nks_label(control.reverb)
	call set_keys_pressed
end function

// Speed
on ui_control(slider_speed)
	call update_speed_switches
	update_engine_pars(control.speed)
	update_nks_label(control.speed)
	call set_keys_pressed
end on

macro speed_switch_callbacks(#mode#)
	on ui_control (switch_#mode#)
		slider_speed := speedMode.#mode#
		call update_speed_switches
		update_engine_pars(control.speed)
		update_nks_label(control.speed)
		call set_keys_pressed
	end on
end macro
literate_macro(speed_switch_callbacks) on speedModes

// Direction
on ui_control(slider_direction)
	call update_direction_switches
	update_nks_label(control.direction)
	call set_keys_pressed
end on

macro direction_switch_callbacks(#mode#)
	on ui_control (switch_#mode#)
		slider_direction := directionMode.#mode#
		call update_direction_switches
		update_nks_label(control.direction)
		call set_keys_pressed
	end on
end macro
literate_macro(direction_switch_callbacks) on directionModes

// Legato/Quantize
on ui_control(slider_legato)
	call update_legato_switches
	update_nks_label(control.legato)
	call set_keys_pressed
end on

macro legato_switch_callbacks(#mode#)
	on ui_control (switch_#mode#)
		slider_legato := legatoMode.#mode#
		call update_legato_switches
		update_nks_label(control.legato)
		call set_keys_pressed
	end on
end macro
literate_macro(legato_switch_callbacks) on legatoModes

// Release Samples
on ui_control(slider_releaseSamples)
	call update_releaseSamples_switches
	update_nks_label(control.releaseSamples)
	call set_keys_pressed
end on

macro releaseSamples_switch_callbacks(#mode#)
	on ui_control (switch_#mode#)
		slider_releaseSamples := releaseSampleMode.#mode#
		call update_releaseSamples_switches
		update_nks_label(control.releaseSamples)
		call set_keys_pressed
	end on
end macro
literate_macro(releaseSamples_switch_callbacks) on releaseSampleModes

on ui_control(switch_releaseTrigger)
	switch_releaseTrigger := 0
	key_down[release_trigger_keyswitches[0]] := 1
	key_down[release_trigger_keyswitches[1]] := 1
	call trigger_release_samples_for_all_ripples
	set_key_pressed(release_trigger_keyswitches[0], 1)
	set_key_pressed(release_trigger_keyswitches[1], 1)
	wait(100000)
	set_key_pressed(release_trigger_keyswitches[0], 0)
	set_key_pressed(release_trigger_keyswitches[1], 0)
end on

on ui_control (switch_logoAnimTrigger)
	label_version -> hide := HIDE_PART_NOTHING
	timestamp_version_shown := ENGINE_UPTIME
	if slider_logoAnim = 0
		slider_logoAnim := 0
		while slider_logoAnim < 127
			inc(slider_logoAnim)
			wait(5000)
		end while
		slider_logoAnim := 0
	end if
end on
