{#pragma save_compiled_source ..\..\Resources\scripts\script.txt}

import "Utilities"
import "Functions/Functions.ksp"

on init
	message("")
	utilities.icb
	engine.ICB()
	tcm.init(1000)
	SET_CONDITION(TCM_LARGE)

	set_key_pressed_support(1)
	set_snapshot_type(3)

	declare dev_mode[1]
	load_array(dev_mode, 2)

	set_listener(NI_SIGNAL_TIMER_MS, 1000000/30) // 30 fps
	set_listener(NI_SIGNAL_TRANSP_START, 1)
	set_listener(NI_SIGNAL_TRANSP_STOP, 1)

	SET_CONDITION(NO_SYS_SCRIPT_PEDAL)

	declare i

	{{ Constants }}
	define UI_WIDTH  := 900
	define UI_HEIGHT := 427
	declare const NUM_ARTICULATIONS := 3
	declare const DOWN := 0
	declare const UP := 1
	declare const NUM_RRS := 4
	declare const MAX_NUM_CHORD_IDS := 1000
	define MAX_NUM_NOTES := 64
	define MAX_RIPPLE_HISTORY := 100
	define NUM_MIDI_PAGES := 2
	define NUM_MIDI_CLIPS := (12 * NUM_MIDI_PAGES)

	{{ Event pars }}
	macro declare_event_par(#par#)
		declare custom_event_#par#[1000000]
		property event.#par#
			function get(id) -> result
				result := custom_event_#par#[id mod 1000000]
			end function
		
			function set(id, value)
				custom_event_#par#[id mod 1000000] := value
			end function
		end property
	end macro

	define CUSTOM_EVENT_PARS := ...
	source                            , ...
	note                              , ...
	velocity                          , ...
	low_note                          , ...
	high_note                         , ...
	origin_note                       , ...
	dest_note                         , ...
	first_note                        , ...
	second_note                       , ...
	row                               , ...
	direction                         , ...
	artic                             , ...
	voice                             , ...
	note_off_timestamp                , ...
	release_length                    , ...
	release_sample_length             , ...
	time_til_note_off                 , ...
	release_note                      , ...
	brightness_on_release             , ...
	waiting_to_trigger_release_sample , ...
	releasing                         , ...
	dest_note_released                , ...
	start_note_released               , ...
	triggered_by_mf                   , ...
	type

	literate_macro(declare_event_par) on CUSTOM_EVENT_PARS

	define RELEASE_SAMPLE := 1
	declare !direction_strings[2] := ("triangle left", "triangle right")
	declare const RECORDED_DURATION_QUARTER := 545455
	declare const RECORDED_DURATION_EIGHTH := 272727
	declare const MAX_INTERVAL := 5
	declare const MIN_BRIGHTNESS := 24
	define CLIP_MARGIN := 4

	{{ Options constants }}
	// Speed
	declare !speed_texts[] := ("Half", "Triplet", "Original", "Triplet", "Double")
	declare ?speeds[5]
	speeds[0] := 2.0
	speeds[1] := 1.5
	speeds[2] := 1.0
	speeds[3] := 0.75
	speeds[4] := 0.5

	declare ?speed_multiplier[5]
	speed_multiplier[0] := 4.0
	speed_multiplier[1] := 1.66
	speed_multiplier[2] := 1.0
	speed_multiplier[3] := 0.66
	speed_multiplier[4] := 0.25

	// Articulation
	const ARTIC
		QUARTERS
		EIGHTHS
		SIXTEENTHS
	end const
	declare !articulation_texts[] := ("Quarters", "Eighths", "Sixteenths")

	// Direction
	const DIRECTION_MODE
		DOWN
		ASPLAYED
		UP
	end const
	declare !direction_mode_texts[] := ("Down", "As Played", "Up")

	// Legato
	const LEGATO_MODE
		OFF
		SYNC_TO_PITCH
		SYNC_TO_RIPPLE
		SYNC_TO_SWELL
	end const
	declare !legato_mode_texts[] := ("Off", "Sync to Pitch", "Sync to Ripple", "Sync to Swell")

	// Release samples
	const RELEASE_SAMPLES
		OFF
		SOFT
		LOUD
	end const
	declare !releaseMode_texts[] := ("Off", "Soft", "Loud")

	declare release_group[ARTIC.SIZE]
	release_group[ARTIC.QUARTERS]   := get_group_idx("quarters releases")
	release_group[ARTIC.EIGHTHS]    := get_group_idx("eighths releases")
	release_group[ARTIC.SIXTEENTHS] := get_group_idx("eighths releases")

	{{ Keyswitch constants }}
	declare const LOWEST_KEY  := 36
	declare const HIGHEST_KEY := 72
	declare articulation_keyswitches[NUM_ARTICULATIONS]      := (29, 31, 33)
	declare speed_keyswitches[NUM_SPEEDS]                    := (72+5, 72+7, 72+9, 72+11, 72+12)
	declare direction_keyswitches[DIRECTION_MODE.SIZE]       := (72+14, 72+16, 72+17)
	declare legato_keyswitches[LEGATO_MODE.SIZE]             := (72+19, 72+21, 72+23, 72+24)
	declare release_sample_keyswitches[RELEASE_SAMPLES.SIZE] := (72+26, 72+28, 72+29)
	declare release_trigger_keyswitches[2] := (24, 108)
		
	// Formatted for Reascript:
	// articulation_keyswitches   = {29, 31, 33}
	// speed_keyswitches          = {72+5, 72+7, 72+9, 72+11, 72+12}
	// direction_keyswitches      = {72+14, 72+16, 72+17}
	// legato_keyswitches         = {72+19, 72+21, 72+23, 72+24}
	// release_sample_keyswitches = {72+26, 72+28}

	// Fill the all_keyswitches array with all the other keyswitch arrays
	declare all_keyswitches[64]
	declare total_num_keyswitches
	for i := 0 to NUM_ARTICULATIONS - 1
		all_keyswitches[total_num_keyswitches] := articulation_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to NUM_SPEEDS - 1
		all_keyswitches[total_num_keyswitches] := speed_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to DIRECTION_MODE.SIZE - 1
		all_keyswitches[total_num_keyswitches] := direction_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to LEGATO_MODE.SIZE - 1
		all_keyswitches[total_num_keyswitches] := legato_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	for i := 0 to RELEASE_SAMPLES.SIZE - 1
		all_keyswitches[total_num_keyswitches] := release_sample_keyswitches[i]
		inc(total_num_keyswitches)
	end for
	

	{{ Length Constants }}
	declare rec_time_sample_lengths[ARTIC.SIZE]
	rec_time_sample_lengths[ARTIC.QUARTERS]   := RECORDED_DURATION_QUARTER * 16
	rec_time_sample_lengths[ARTIC.EIGHTHS]    := RECORDED_DURATION_QUARTER * 8
	rec_time_sample_lengths[ARTIC.SIXTEENTHS] := RECORDED_DURATION_QUARTER * 8

	declare rec_time_ripple_lengths[ARTIC.SIZE]
	rec_time_ripple_lengths[ARTIC.QUARTERS]   := RECORDED_DURATION_QUARTER * 2
	rec_time_ripple_lengths[ARTIC.EIGHTHS]    := RECORDED_DURATION_QUARTER
	rec_time_ripple_lengths[ARTIC.SIXTEENTHS] := RECORDED_DURATION_QUARTER

	declare ripple_length_ticks[ARTIC.SIZE]
	ripple_length_ticks[ARTIC.QUARTERS]   := 960*2
	ripple_length_ticks[ARTIC.EIGHTHS]    := 960
	ripple_length_ticks[ARTIC.SIXTEENTHS] := 960

	declare sample_length_ticks[ARTIC.SIZE]
	sample_length_ticks[ARTIC.QUARTERS]   := 960 * 16
	sample_length_ticks[ARTIC.EIGHTHS]    := 960 * 8
	sample_length_ticks[ARTIC.SIXTEENTHS] := 960 * 8

	declare pitch_fractions[ARTIC.SIZE]
	pitch_fractions[ARTIC.QUARTERS]   := 2
	pitch_fractions[ARTIC.EIGHTHS]    := 2
	pitch_fractions[ARTIC.SIXTEENTHS] := 4

	{{ Variables }}
	declare timestamp_version_shown
	declare num_active_ripples
	declare num_keys_pressed
	declare key_active[128]
	declare key_down[128]
	declare key_released[128]
	fill(key_released, 1)
	declare notes_to_release[1000]
	declare voices_to_release[1000]
	declare num_notes_to_release
	declare num_ripple_voices[128]
	declare note_used_by_ripple[128]
	declare key_timestamp[128]
	declare key_history[100]
	declare ripple_id_history[MAX_RIPPLE_HISTORY]
	declare direction
	declare row
	declare first_ripple_timestamp
	declare cur_midi_page
	declare read cur_artic
	declare all_keys_released := 1
	declare recent_release_trigger_key := release_trigger_keyswitches[0]
	declare velo[128]
	declare event_ids[128]
	velo[recent_release_trigger_key] := 64

	// Fading graphics
	declare ~midiInstructions_opacity := 0.0
	declare ~midiCover_opacity := 0.0
	declare ~smoothed_midiInstructions_opacity
	declare ~smoothed_midiCover_opacity

	// Midi
	declare midi_event_id[NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_command [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_pos     [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_byte_1  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_byte_2  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare midi_length  [NUM_MIDI_CLIPS, MF_BUFFER_SIZE]
	declare clip_length  [NUM_MIDI_CLIPS]
	declare clip_loop_enabled  [NUM_MIDI_CLIPS]
	declare num_midi_events[NUM_MIDI_CLIPS]
	declare num_midi_notes[NUM_MIDI_CLIPS]
	declare num_midi_ccs[NUM_MIDI_CLIPS]
	declare time_started[NUM_MIDI_CLIPS]
	declare cur_event[NUM_MIDI_CLIPS]
    define clip_poly := NI_UI_ID -> custom_id
    define cur_event_poly := cur_event[NI_UI_ID -> custom_id]
    declare playing[NUM_MIDI_CLIPS]
    declare looping[NUM_MIDI_CLIPS]
    declare midi_file_pos_ticks[NUM_MIDI_CLIPS]
	define midi_file_pos_ticks_poly := midi_file_pos_ticks[NI_UI_ID -> custom_id]
	declare cb_id[NUM_MIDI_CLIPS]

	{{ Iterators }}
	declare hist_i
	declare voice_i
	declare par_i
	declare key_i
	declare ripple_i
	declare b
	declare g
	declare v
	declare r
	declare k
	declare n
	declare e
	declare event_i
	declare other_event_i
	declare row_i
	declare vel_i
	declare clip_i

	{{ MIDI }}
	mf_reset()
	define MF_BUFFER_SIZE := 1000
	mf_set_buffer_size(MF_BUFFER_SIZE)
	mf_set_num_export_areas(NUM_MIDI_CLIPS + 1)
	// declare ui_label midi_clip[NUM_MIDI_CLIPS](2,2)
	mf_insert_file(get_folder(GET_FOLDER_PATCH_DIR) & "/../Data/midi.mid", 0, 0, 0)

	// Insert midi data into arrays to be played back
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		// Notes
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_NOTE_ON
				midi_event_id[clip_i, num_midi_events[clip_i]] := mf_get_id()
				midi_command [clip_i, num_midi_events[clip_i]] := mf_get_command()
				midi_pos     [clip_i, num_midi_events[clip_i]] := mf_get_pos()
				midi_byte_1  [clip_i, num_midi_events[clip_i]] := mf_get_byte_one()
				midi_byte_2  [clip_i, num_midi_events[clip_i]] := mf_get_byte_two()
				midi_length  [clip_i, num_midi_events[clip_i]] := mf_get_note_length()
				inc(num_midi_events[clip_i])
				inc(num_midi_notes[clip_i])
			end if
			mf_get_next(clip_i)
		end while

		// Insert pedal CC's at the correct times
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC and mf_get_byte_one() = 64
				declare cc_inserted
				cc_inserted := 0
				for event_i := 0 to num_midi_events[clip_i] - 1
					if cc_inserted = 0
						// Find which events to insert this CC between
						declare insert_index
						insert_index := -1

						// If it comes before the first event
						if event_i = 0
							if mf_get_pos() < midi_pos[clip_i, 0]
								insert_index := 0
								// message("inserted before the first event")
							end if
						end if

						// If it comes sandwiched between two events
						if in_range(event_i, 1, num_midi_events[clip_i] - 2)
							if mf_get_pos() > midi_pos[clip_i, event_i] and mf_get_pos() < midi_pos[clip_i, event_i + 1]
								insert_index := event_i + 1
							end if
						end if

						// If it comes after the last event
						if event_i = num_midi_events[clip_i] - 1
							if mf_get_pos() > midi_pos[clip_i, num_midi_events[clip_i] - 1]
								insert_index := num_midi_events[clip_i]
							end if
						end if

						// If it's right on another event
						if mf_get_pos() = midi_pos[clip_i, event_i]
							insert_index := event_i
							// message("right on another event: " & insert_index)
						end if

						if insert_index # -1
							cc_inserted := 1							

							// Move all following events back one slot
							for other_event_i := MF_BUFFER_SIZE - 1 downto insert_index + 1
								midi_event_id[clip_i, other_event_i] := midi_event_id[clip_i, other_event_i - 1]
								midi_command [clip_i, other_event_i] := midi_command [clip_i, other_event_i - 1]
								midi_pos     [clip_i, other_event_i] := midi_pos     [clip_i, other_event_i - 1]
								midi_byte_1  [clip_i, other_event_i] := midi_byte_1  [clip_i, other_event_i - 1]
								midi_byte_2  [clip_i, other_event_i] := midi_byte_2  [clip_i, other_event_i - 1]
								midi_length  [clip_i, other_event_i] := midi_length  [clip_i, other_event_i - 1]
							end for

							// Add CC
							midi_event_id[clip_i, insert_index] := mf_get_id()
							midi_command [clip_i, insert_index] := mf_get_command()
							midi_pos     [clip_i, insert_index] := mf_get_pos()
							midi_byte_1  [clip_i, insert_index] := mf_get_byte_one()
							midi_byte_2  [clip_i, insert_index] := mf_get_byte_two()
						end if
					end if
				end for
				inc(num_midi_events[clip_i])
				inc(num_midi_ccs[clip_i])
			end if
			mf_get_next(clip_i)
		end while
	end for

	// Find clip lengths
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		mf_get_first(clip_i) 
		while mf_get_command() # 0
			if mf_get_command() = MIDI_COMMAND_CC
				if mf_get_byte_one() = 103
					clip_length[clip_i] := mf_get_pos()
					if mf_get_byte_two() = 127
						clip_loop_enabled[clip_i] := 1
					else
						clip_loop_enabled[clip_i] := 0
					end if
					// mf_remove_event(mf_get_id()) // clean up
				end if
			end if
			mf_get_next(clip_i)
		end while
	end for

	{{ UI }}
	import "F2K/UI Code.ksp"
	set_control_par_str(INST_ICON_ID, CONTROL_PAR_PICTURE, "insticon")

	label_version -> hide := HIDE_WHOLE_CONTROL

	// Midi page
	declare panel_midiPg[NUM_MIDI_PAGES]
	declare switch_midiPgChooser[NUM_MIDI_PAGES]
	macro write_midiPg_ui_id_to_array(#i#)
		panel_midiPg[#i#] := get_ui_id(panel_midiPg#i#)
		switch_midiPgChooser[#i#] := get_ui_id(switch_midiPgChooser#i#)
	end macro
	iterate_macro(write_midiPg_ui_id_to_array) := 0 to NUM_MIDI_PAGES - 1

	// Need to initialize midi page chooser switches because F2K makes them persistent
	for i := 0 to NUM_MIDI_PAGES - 1
		switch_midiPgChooser[i] -> value := 0
	end for
	switch_midiPgChooser[0] -> value := 1

	declare ui_slider mf_cursor[NUM_MIDI_CLIPS](0, 1000)
	declare midi_clip_panel_id[NUM_MIDI_CLIPS]
	declare midi_clip_id[NUM_MIDI_CLIPS]
	declare midi_clip_dnd_id[NUM_MIDI_CLIPS]
	declare midi_clip_preview_id[NUM_MIDI_CLIPS]
	macro put_midi_clip_ui_controls_into_arrays(#i#)
		midi_clip_panel_id[#i#]   := get_ui_id(panel_clip#i#)
		midi_clip_id[#i#]         := get_ui_id(label_clip#i#)
		midi_clip_dnd_id[#i#]     := get_ui_id(label_clip_dnd#i#)
		midi_clip_preview_id[#i#] := get_ui_id(switch_preview#i#)
	end macro
	iterate_macro(put_midi_clip_ui_controls_into_arrays) := 0 to NUM_MIDI_CLIPS - 1

	for i := 0 to NUM_MIDI_CLIPS - 1
		mf_set_export_area("Ripple Cello", -1, -1, i, i)
		mf_copy_export_area(i + 1)
		midi_clip_dnd_id[i] -> midi_export_area_idx := i + 1
		midi_clip_dnd_id[i] -> dnd_behaviour := 1
		midi_clip_preview_id[i] -> z_layer := 1
		midi_clip_preview_id[i] -> custom_id := i
		midi_clip_preview_id[i] -> value := 0
		mf_cursor[i] -> picture := "mf_cursor"
		mf_cursor[i] -> hide := HIDE_WHOLE_CONTROL
		mf_cursor[i] -> parent_panel := midi_clip_panel_id[i]
		// set_bounds(mf_cursor[i], 5, 0, 1, midi_clip_id[i] -> height)
		set_bounds(mf_cursor[i], 0, 0)
	end for

	button_showMidi := 0
	update_midi_visibility()


	// Z layers

	// putting panel_midi on z_layer 1 would mess up the hover states. 
	// So instead, I'm just hiding all z_layer=1 controls whenever I show panel_midi
	panel_midi -> z_layer := 0

	switch_generalInfoDisp        -> hide := HIDE_WHOLE_CONTROL
	switch_articulationsInfoDisp  -> hide := HIDE_WHOLE_CONTROL
	switch_optionsInfoDisp        -> hide := HIDE_WHOLE_CONTROL
	switch_speedInfoDisp          -> hide := HIDE_WHOLE_CONTROL
	switch_directionInfoDisp      -> hide := HIDE_WHOLE_CONTROL
	switch_legatoInfoDisp         -> hide := HIDE_WHOLE_CONTROL
	switch_releaseSamplesInfoDisp -> hide := HIDE_WHOLE_CONTROL


	switch_generalInfoDisp        -> z_layer := 1
	switch_articulationsInfoDisp  -> z_layer := 1
	switch_optionsInfoDisp        -> z_layer := 1
	switch_speedInfoDisp          -> z_layer := 1
	switch_directionInfoDisp      -> z_layer := 1
	switch_legatoInfoDisp         -> z_layer := 1
	switch_releaseSamplesInfoDisp -> z_layer := 1

	panel_midiPgChooser   -> z_layer := 1
	switch_midiPgChooser0 -> z_layer := 1
	switch_midiPgChooser1 -> z_layer := 1

	panel_articulations  -> z_layer := 1
	panel_fx             -> z_layer := 1
	panel_speed          -> z_layer := 1
	panel_direction      -> z_layer := 1
	panel_legato         -> z_layer := 1
	panel_releaseSamples -> z_layer := 1



	declare key_ids[128]
	macro assign_key_id(#i#)
		key_ids[#i# + LOWEST_KEY]        := get_ui_id(label_oct0.note#i#)
		key_ids[#i# + LOWEST_KEY + 12]   := get_ui_id(label_oct1.note#i#)
		key_ids[#i# + LOWEST_KEY + 12*2] := get_ui_id(label_oct2.note#i#)
	end macro
	iterate_macro(assign_key_id) := 0 to 11
	key_ids[72] := get_ui_id(label_oct2.note12)

	for key_i := LOWEST_KEY to HIGHEST_KEY
		key_ids[key_i] -> value := 0
	end for

	define NUM_REVERB_PRESETS := 3
	define NUM_PRESET_PARS := 8
	declare !reverb_preset_names[NUM_REVERB_PRESETS] := ("Small", "Medium", "Large")
	declare read reverb_preset[NUM_REVERB_PRESETS, NUM_PRESET_PARS]
	for i := 0 to NUM_REVERB_PRESETS - 1
		add_menu_item(menu_reverb, reverb_preset_names[i], i)
	end for
	add_menu_item(menu_reverb, "save preset", NUM_REVERB_PRESETS)
	declare read prev_reverb := menu_reverb
	if dev_mode[0] = 0
		set_menu_item_visibility(get_ui_id(menu_reverb), NUM_REVERB_PRESETS, 0)
	end if
	label_reverb -> text_alignment := 1
	label_vol -> font_type := get_font_id("Khula Bold Size 11 on")
	label_reverb -> font_type := get_font_id("Khula Bold Size 11 on")

	// Articulations
	declare articulation_ids[NUM_ARTICULATIONS]
	articulation_ids[0] := get_ui_id(switch_quarters)
	articulation_ids[1] := get_ui_id(switch_eighths)
	articulation_ids[2] := get_ui_id(switch_sixteenths)
	for i := 0 to NUM_ARTICULATIONS - 1
		articulation_ids[i] -> allow_automation := 0
	end for

	// Speed
	define NUM_SPEEDS := 5
	declare speed_ids[NUM_SPEEDS]
	speed_ids[0] := get_ui_id(switch_halfSpeed)
	speed_ids[1] := get_ui_id(switch_slowTripletSpeed)
	speed_ids[2] := get_ui_id(switch_fullSpeed)
	speed_ids[3] := get_ui_id(switch_fastTripletSpeed)
	speed_ids[4] := get_ui_id(switch_doubleSpeed)
	for i := 0 to num_elements(speed_ids) - 1
		speed_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		speed_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		speed_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		speed_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		speed_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		speed_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		speed_ids[i] -> text := speed_texts[i]
		speed_ids[i] -> width := speed_ids[i] -> width + 14
	end for

	// Direction
	switch_up       -> text := "Up"
	switch_down     -> text := "Down"
	switch_asPlayed -> text := "As Played"
	declare direction_mode_ids[DIRECTION_MODE.SIZE]
	direction_mode_ids[0] := get_ui_id(switch_down)
	direction_mode_ids[1] := get_ui_id(switch_asPlayed)
	direction_mode_ids[2] := get_ui_id(switch_up)
	for i := 0 to num_elements(direction_mode_ids) - 1
		direction_mode_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		direction_mode_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		direction_mode_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		direction_mode_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		direction_mode_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		direction_mode_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		// direction_mode_ids[i] -> text := speed_texts[i]
	end for
	switch_down     -> width := switch_down     -> width + 13
	switch_asPlayed -> width := switch_asPlayed -> width + 19
	switch_up       -> width := switch_up       -> width + 7

	// Legato/Quantize
	switch_noLegato     -> text := "Off"
	switch_syncToPitch  -> text := "Pitch"
	switch_syncToRipple -> text := "Ripple"
	switch_syncToSwell  -> text := "Swell"
	declare legato_ids[LEGATO_MODE.SIZE]
	legato_ids[0] := get_ui_id(switch_noLegato)
	legato_ids[1] := get_ui_id(switch_syncToPitch)
	legato_ids[2] := get_ui_id(switch_syncToRipple)
	legato_ids[3] := get_ui_id(switch_syncToSwell)
	for i := 0 to num_elements(legato_ids) - 1
		legato_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		legato_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		legato_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		legato_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		legato_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		legato_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		// direction_mode_ids[i] -> text := speed_texts[i]
	end for

	// Release Mode
	declare releaseMode_ids[RELEASE_SAMPLES.SIZE]
	releaseMode_ids[0] := get_ui_id(switch_releaseSamples.off)
	releaseMode_ids[1] := get_ui_id(switch_releaseSamples.soft)
	releaseMode_ids[2] := get_ui_id(switch_releaseSamples.loud)
	for i := 0 to num_elements(releaseMode_ids) - 1
		releaseMode_ids[i] -> font_type             := get_font_id("Khula Bold Size 11 off")
		releaseMode_ids[i] -> font_type_on          := get_font_id("Khula Bold Size 11 on")
		releaseMode_ids[i] -> font_type_off_pressed := get_font_id("Khula Bold Size 11 off pressed")
		releaseMode_ids[i] -> font_type_on_pressed  := get_font_id("Khula Bold Size 11 on pressed")
		releaseMode_ids[i] -> font_type_off_hover   := get_font_id("Khula Bold Size 11 off hover")
		releaseMode_ids[i] -> font_type_on_hover    := get_font_id("Khula Bold Size 11 on hover")
		releaseMode_ids[i] -> text := releaseMode_texts[i]
	end for
	switch_releaseSamples.off  -> width := switch_releaseSamples.off  -> width + 14
	switch_releaseSamples.soft -> width := switch_releaseSamples.soft -> width + 14
	switch_releaseSamples.loud -> width := switch_releaseSamples.loud -> width + 14

	switch_releaseTrigger -> allow_automation := 0


	slider_speed       -> mouse_behaviour := 2000
	slider_direction   -> mouse_behaviour := 2000
	slider_legato      -> mouse_behaviour := 2000
	slider_releaseSamples -> mouse_behaviour := 2000

	slider_speed     -> default := 2
	slider_direction -> default := 1
	slider_legato    -> default := 0

	slider_vol -> default := 500000
	slider_reverb -> default := 500000

	menu_reverb -> textpos_y := 100

	// Old

	set_voice_limit(NI_VL_TMPRO_STANDARD, MAX_RIPPLE_HISTORY)
	declare ui_slider ripple[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple) - 1
		// ripple[i] -> picture := "ripple 0"
		ripple[i] -> z_layer := -1
		ripple[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	declare ui_slider ripple_swell[MAX_RIPPLE_HISTORY](0,127)
	for i := 0 to num_elements(ripple_swell) - 1
		// ripple_swell[i] -> picture := "ripple_swell 0"
		ripple_swell[i] -> z_layer := -1
		ripple_swell[i] -> hide := HIDE_WHOLE_CONTROL
	end for

	{{ Automation }}
	slider_vol -> automation_id := 0
	slider_vol -> automation_name := "Expression"
	slider_reverb -> automation_id := 1
	slider_reverb -> automation_name := "Reverb"

	// DEV
	group[ARTIC.QUARTERS].speed   := V2E_speed(18*2)
	group[ARTIC.EIGHTHS].speed    := V2E_speed(18)
	group[ARTIC.SIXTEENTHS].speed := V2E_speed(18)
	group[get_group_idx("quarters releases")].speed := V2E_speed(12)
	group[get_group_idx("eighths releases")].speed := V2E_speed(12)


end on

on persistence_changed
	persistence_changed_callback()
end on
function persistence_changed_callback()
	call set_key_colors_and_types_and_names
	call set_keys_pressed
	call set_reverb_menu_checkmark
end function

on note
	event[EVENT_ID].source := OUTSIDE_SOURCE
	set_event_par_arr(EVENT_ID, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
	note_callback(EVENT_NOTE, EVENT_VELOCITY, EVENT_ID)
end on
function note_callback(note, velocity, event_id)
	set_key_pressed(note, 1)
	key_down[note] := 1
	velo[note] := velocity

	// Keyswitches
	declare ks_index := search(articulation_keyswitches, note)
	if ks_index # -1
		cur_artic := ks_index
		call update_articulation_switches
	end if

	ks_index := search(speed_keyswitches, note)
	if ks_index # -1
		slider_speed := ks_index
		call update_speed_switches
		call update_speed
	end if

	ks_index := search(direction_keyswitches, note)
	if ks_index # -1
		slider_direction := ks_index
		call update_direction_switches
	end if

	ks_index := search(legato_keyswitches, note)
	if ks_index # -1
		slider_legato := ks_index
		call update_legato_switches
	end if

	ks_index := search(release_sample_keyswitches, note)
	if ks_index # -1
		slider_releaseSamples := ks_index
		call update_releaseMode_switches
	end if

	ks_index := search(release_trigger_keyswitches, note)
	if ks_index # -1
		recent_release_trigger_key := release_trigger_keyswitches[ks_index]
		switch_releaseTrigger := 1
		call trigger_release_samples_for_all_ripples
	end if

	if search(all_keyswitches, note) # -1
		call set_keys_pressed
	end if

	// Playable range
	if in_range(note, LOWEST_KEY, HIGHEST_KEY)
		// Key arrays
		key_active   [note] := 1
		key_timestamp[note] := ENGINE_UPTIME
		velo         [note] := velocity

		// UI keyboard
		key_ids[note] -> picture_state := 1

		// Keys history
		for key_i := num_elements(key_history) - 2 downto 0
			key_history[key_i + 1] := key_history[key_i]
		end for
		key_history[0] := note

		call count_keys_pressed
		if num_keys_pressed > 1
			declare notes[MAX_NUM_NOTES]
			declare intervals[MAX_NUM_NOTES]
			declare played_notes[MAX_NUM_NOTES]
			declare played_intervals[MAX_NUM_NOTES]
			define MAX_NUM_RIPPLES_PER_NOTE := 12
			declare notes[MAX_NUM_RIPPLES_PER_NOTE]
			declare intervals[MAX_NUM_RIPPLES_PER_NOTE]
			declare num_ripples := 0

			// Fill neighbor arrays, to be analyzed later
			declare closest_neighbor := -1
			declare closest_neighbor_interval := 12
			declare neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare lower_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			declare upper_neighbor[MAX_NUM_RIPPLES_PER_NOTE]
			fill(neighbor, 0)
			fill(lower_neighbor, 0)
			fill(upper_neighbor, 0)
			declare num_neighbors := 0
			declare num_lower_neighbors := 0
			declare num_upper_neighbors := 0

			for i := 1 to MAX_INTERVAL
				// Look below and above
				declare dir
				for dir := 0 to 1
					declare sign := dir*2-1
					declare other_note := note + i*sign
					if key_down[other_note] = 1
						neighbor[num_neighbors] := other_note
						inc(num_neighbors)
						if other_note < note
							lower_neighbor[num_lower_neighbors] := other_note
							inc(num_lower_neighbors)
						end if
						if other_note > note
							upper_neighbor[num_upper_neighbors] := other_note
							inc(num_upper_neighbors)
						end if
					end if
				end for
			end for

			if lower_neighbor[0] # 0 and upper_neighbor[0] # 0
				declare lower_neighbor_time_held := ENGINE_UPTIME - key_timestamp[lower_neighbor[0]]
				declare upper_neighbor_time_held := ENGINE_UPTIME - key_timestamp[upper_neighbor[0]]
				declare make_ripples_to_both_adjacent_neighbors
				if abs(upper_neighbor_time_held - lower_neighbor_time_held) < 50
					make_ripples_to_both_adjacent_neighbors := 1
				else
					make_ripples_to_both_adjacent_neighbors := 0
				end if
				if slider_direction = DIRECTION_MODE.UP or slider_direction = DIRECTION_MODE.DOWN
					make_ripples_to_both_adjacent_neighbors := 1
				end if

				if make_ripples_to_both_adjacent_neighbors = 1
					notes[0] := lower_neighbor[0]
					intervals[0] := note - lower_neighbor[0]
					notes[1] := upper_neighbor[0]
					intervals[1] := note - upper_neighbor[0]
					num_ripples := 2
				else if make_ripples_to_both_adjacent_neighbors = 0
					if search(key_history, lower_neighbor[0]) < search(key_history, upper_neighbor[0])
						// lower neighbor happened more recently
						notes[0] := lower_neighbor[0]
						intervals[0] := note - lower_neighbor[0]
					else
						// upper neighbor happened more recently
						notes[0] := upper_neighbor[0]
						intervals[0] := note - upper_neighbor[0]
					end if
					num_ripples := 1
				end if
			else
				// Find ripple to play from history
				notes[0]     := key_history[1]
				intervals[0] := key_history[0] - key_history[1]
				num_ripples := 1

				if abs(intervals[0]) > MAX_INTERVAL
					if num_neighbors > 0
						// If ripples can't be made using history, use closest neighbor, up or down
						notes[0] := neighbor[0]
						intervals[0] := note - neighbor[0]
						num_ripples := 1
					else 
						// If that doesn't work, then don't make any ripples at all
						fill(notes, 0)
						fill(intervals, 0)
						num_ripples := 0
					end if
				end if
			end if

			copy_array(notes, played_notes)
			copy_array(intervals, played_intervals)
			fill(note_used_by_ripple, 0)
			declare ripple_i
			for ripple_i := 0 to num_ripples - 1
				// Swap notes and intervals to change directions
				if slider_direction = DIRECTION_MODE.UP
					if intervals[ripple_i] < 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				else if slider_direction = DIRECTION_MODE.DOWN
					if intervals[ripple_i] > 0
						notes[ripple_i]     := notes[ripple_i] + intervals[ripple_i]
						intervals[ripple_i] := -intervals[ripple_i]
					end if
				end if

				// Get low and high notes
				if intervals[ripple_i] < 0
					declare low_note := notes[ripple_i] + intervals[ripple_i]
					declare high_note := notes[ripple_i]
				else
					low_note := notes[ripple_i]
					high_note := notes[ripple_i] + intervals[ripple_i]
				end if

				// Direction
				if intervals[ripple_i] > 0
					direction := UP
				else
					direction := DOWN
				end if

				// Make sure this particular interval and direction isn't already being played
				declare already_playing := 0
				for r := 0 to MAX_RIPPLE_HISTORY - 1
					if ripple_id_history[r] # 0
						if event[ripple_id_history[r]].low_note = low_note    and key_released[low_note] = 0 ...
						and event[ripple_id_history[r]].high_note = high_note and key_released[high_note] = 0 ...
						and event[ripple_id_history[r]].high_note = high_note ...
						and event[ripple_id_history[r]].direction = direction ...
						and event[ripple_id_history[r]].releasing = 0
							already_playing := 1
						end if
					end if
				end for

				key_released[low_note] := 0
				key_released[high_note] := 0

				if already_playing = 0
					declare offset_real_time
					declare do_legato := 0

					call count_active_ripples
					if num_active_ripples > 0
						do_legato := 1
					end if

					if all_keys_released = 1
						do_legato := 0
					else
						do_legato := 1
					end if
					all_keys_released := 0

					if do_legato = 0
						first_ripple_timestamp := ENGINE_UPTIME
						declare real_legato_time := 0
						offset_real_time := 0
					else
						// declare first_ripple := find_first_active_ripple()
						real_legato_time := (ENGINE_UPTIME - first_ripple_timestamp) * 1000
						real_legato_time := int(real(real_legato_time) / speeds[slider_speed])
						select slider_legato
							case LEGATO_MODE.SYNC_TO_PITCH
								real_legato_time := real_legato_time + ticks_to_ms(1) // For when you add a ripple using grid-snapped notes.
								offset_real_time := real_legato_time mod ticks_to_ms(ripple_length_ticks[cur_artic] / pitch_fractions[cur_artic])
							case LEGATO_MODE.SYNC_TO_RIPPLE
								offset_real_time := real_legato_time mod ticks_to_ms(ripple_length_ticks[cur_artic])
							case LEGATO_MODE.SYNC_TO_SWELL
								offset_real_time := real_legato_time mod ticks_to_ms(sample_length_ticks[cur_artic])
						end select
					end if
					declare offset_rec_time := map_i_2i_2i_i(offset_real_time, 0, ticks_to_ms(sample_length_ticks[cur_artic]), 0, rec_time_sample_lengths[cur_artic])
					declare note_id := play_note(notes[ripple_i], 64 + intervals[ripple_i], offset_rec_time, 0)
					declare volume  := map_i_2i_2i_i(velocity, 1, 127, -12000, 3000)
					if offset_rec_time = 0
						// tmpro causes a bit of a bump sometimes. This hides that.
						fade_in(note_id, DURATION_SIXTEENTH)
					end if
					change_vol(note_id, volume, CHANGE_ABSOLUTE)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, cur_artic)
					event[note_id].artic := cur_artic
					event[note_id].note := note
					event[note_id].low_note := low_note
					event[note_id].high_note := high_note
					event[note_id].origin_note := notes[ripple_i]
					event[note_id].dest_note := notes[ripple_i] + intervals[ripple_i]
					event[note_id].first_note := played_notes[ripple_i]
					event[note_id].second_note := played_notes[ripple_i] + played_intervals[ripple_i]
					event[note_id].velocity := velocity

					if note_used_by_ripple[event[note_id].second_note] = 0
						event[note_id].voice := num_ripple_voices[event[note_id].second_note]
						inc(num_ripple_voices[event[note_id].second_note])
						note_used_by_ripple[event[note_id].second_note] := 1
					else
						event[note_id].voice := num_ripple_voices[event[note_id].second_note] - 1
					end if
					event[note_id].direction := direction
					event[note_id].source := OUTSIDE_SOURCE
					event[note_id].triggered_by_mf := event[event_id].triggered_by_mf

					// Push note id to ripple history
					for r := MAX_RIPPLE_HISTORY - 2 downto 0
						ripple_id_history[r + 1] := ripple_id_history[r]
					end for
					ripple_id_history[0] := note_id

					// Fade in
					if real_legato_time > 0
						declare real_time_pos_in_ripple := (real_legato_time - ticks_to_ms(2)) mod ticks_to_ms(ripple_length_ticks[cur_artic])
						real_time_pos_in_ripple := int(real(real_time_pos_in_ripple) / speeds[slider_speed])
						declare fade_in_time := ticks_to_ms(ripple_length_ticks[cur_artic]) - real_time_pos_in_ripple
						if fade_in_time < 150000
							fade_in_time := 150000
						end if
						fade_in(note_id, fade_in_time)
					end if

				end if
			end for
		end if
	end if
end function


on release
	release_callback(EVENT_NOTE, EVENT_ID)
end on
function release_callback(note, event_id)
	key_released[note] := 1
	key_down[note] := 0
	if search(all_keyswitches, note) = -1
		set_key_pressed(note, 0)
	end if

	if note = release_trigger_keyswitches[0] or note = release_trigger_keyswitches[1]
		switch_releaseTrigger := 0
	end if

	if in_range(note, LOWEST_KEY, HIGHEST_KEY) and event[event_id].source = OUTSIDE_SOURCE
		key_ids[note] -> picture_state := 0

		// move all history
		declare history_index := search_for_note_in_key_history(note)
		if history_index > -1
			for key_i := history_index to num_elements(key_history) - 2
				key_history[key_i] := key_history[key_i + 1]
			end for
		end if
			
		if CC[64] < 10
			key_active[note] := 0
			if num_ripple_voices[note] = 0
				release(note, 0)
			else
				for voice_i := 0 to num_ripple_voices[note] - 1
					release(note, voice_i)
				end for
			end if
			num_ripple_voices[note] := 0
		else
			// fill up array of notes/voices to be released when pedal comes up
			notes_to_release[num_notes_to_release] := note
			voices_to_release[num_notes_to_release] := num_ripple_voices[note] - 1
			inc(num_notes_to_release)
		end if
	end if
end function

function release(note, voice)
	if voice = -1
		msg(voice)
	end if

	declare r
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] # 0
			if voice = event[ripple_id_history[r]].voice
				declare artic := event[ripple_id_history[r]].artic
				declare rec_time_pos_in_ripple := ripple_id_history[r] -> play_pos mod rec_time_ripple_lengths[artic]
				
				declare real_time_pos_in_pulse := map_i_2i_2i_i(rec_time_pos_in_ripple, 0, rec_time_ripple_lengths[artic], 0, ticks_to_ms(ripple_length_ticks[artic]))
				real_time_pos_in_pulse := int(real(real_time_pos_in_pulse) * speeds[slider_speed])
				declare real_time_ripple_length := ticks_to_ms(int(real(ripple_length_ticks[artic]) * speeds[slider_speed]))
				declare time_til_end_of_ripple := (real_time_ripple_length - real_time_pos_in_pulse) / 1000

				if note = event[ripple_id_history[r]].second_note
					event[ripple_id_history[r]].note_off_timestamp := ENGINE_UPTIME

					declare play_release_sample
					if slider_releaseSamples = 0
						if key_down[recent_release_trigger_key] = 1
							play_release_sample := 1
						else
							play_release_sample := 0
						end if
					else if slider_releaseSamples > 0
						play_release_sample := 1
					end if

					if play_release_sample = 0
						event[ripple_id_history[r]].releasing := 1
						declare fade_out_time := time_til_end_of_ripple //+ ticks_to_ms(ripple_length_ticks[artic])
						event[ripple_id_history[r]].release_length := fade_out_time
						// if fade_out_time < DURATION_SIXTEENTH / 8 / 1000
						// 	fade_out_time := ticks_to_ms(ripple_length_ticks[artic] / pitch_fractions[artic]) / 1000
						// end if
						fade_out(ripple_id_history[r], fade_out_time * 1000, STOP_VOICE_AFTER_FADE_OUT)
					else
						event[ripple_id_history[r]].time_til_note_off := time_til_end_of_ripple
						event[ripple_id_history[r]].waiting_to_trigger_release_sample := 1
					end if
				end if

				// Old:
				// dynamic_release(note)
				// immediate_release(note)
			end if
		end if
	end for

	call count_keys_pressed
	if num_keys_pressed = 0
		all_keys_released := 1
	end if
end function


on controller
	controller_callback(CC_NUM)
end on
function controller_callback(cc_num)
	if cc_num = 64
		declare prev_cc64
		if CC[64] < 10 and prev_cc64 >= 10
			declare i
			for i := 0 to num_notes_to_release - 1
				key_active[notes_to_release[i]] := key_down[notes_to_release[i]]
				release(notes_to_release[i], voices_to_release[i])
			end for
			fill(notes_to_release, 0)
			fill(voices_to_release, 0)
			num_notes_to_release := 0

			// declare key_i
			// for key_i := LOWEST_KEY to HIGHEST_KEY
				// Release most recent voice if the key is up
				// if key_down[key_i] = 0 and key_active[key_i] = 1
				// 	key_active[key_i] := 0
				// 	release(key_i, num_ripple_voices[key_i] - 1)
				// end if

				// Release all other previous voices, no matter what
				// for voice_i := 0 to num_ripple_voices[key_i] - 2
				// 	release(key_i, voice_i)
				// end for


				// set num_ripple_voices
				// num_ripple_voices[key_i] := key_down[key_i]
			// end for
		end if
		prev_cc64 := CC[64]
	end if
end function


on listener
	listener_callback()
end on
function listener_callback
	select NI_SIGNAL_TYPE
		case NI_SIGNAL_TIMER_MS
			call remove_ripple_ids_from_history_after_they_have_faded_out
			call ripple_animations
			// call update_recorded_midi
			call midi_clip_play_cursors
			call info_graphics_animation
			call play_release_samples_when_its_time
			call crossfaded_looping
			call hide_version
		case NI_SIGNAL_TRANSP_START
			first_ripple_timestamp := ENGINE_UPTIME
			stop_ideas_panel()

		case NI_SIGNAL_TRANSP_STOP
			stop_ideas_panel()
	end select
end function



on ui_controls
	ui_controls_callback()
end on
function ui_controls_callback()
	declare index
	declare event_ids[128]
	declare e

	// Show midi
	if NI_UI_ID = get_ui_id(button_showMidi)
		if button_showMidi = 0
			macro stop_ideas_panel
				set_controller(64, 0)
				wait(1)
				for clip_i := 0 to num_elements(midi_clip_preview_id) - 1
					midi_clip_preview_id[clip_i] -> value := 0
					if playing[clip_i] = 1
						get_event_ids(event_ids)
						for e := 0 to num_elements(event_ids) - 1
							if event[event_ids[e]].triggered_by_mf = clip_i + 1
								fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
								if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
									key_ids[event_ids[e] -> note] -> picture_state := 0
									key_down[event_ids[e] -> note] := 0
									key_active[event_ids[e] -> note] := 0
								end if
							end if
						end for
						playing[clip_i] := 0
						looping[clip_i] := 0
					end if
				end for
			end macro
			stop_ideas_panel()
		end if
		call update_midi_visibility
	end if
	if NI_UI_ID = get_ui_id(switch_closeMidi)
		button_showMidi := 0
		stop_ideas_panel()
		call update_midi_visibility
	end if

	// Midi page chooser
	index := search(switch_midiPgChooser, NI_UI_ID)
	if index # -1
		cur_midi_page := index
		call update_midi_visibility
		for i := 0 to NUM_MIDI_PAGES - 1
			if i = cur_midi_page
				switch_midiPgChooser[i] -> value := 1
			else
				switch_midiPgChooser[i] -> value := 0
			end if
		end for
	end if

	// General info
	if NI_UI_ID = get_ui_id(button_generalInfo)
		button_showMidi := 0
		call update_midi_visibility
		if switch_generalInfoDisp -> hide = HIDE_WHOLE_CONTROL
			switch_generalInfoDisp -> hide := HIDE_PART_NOTHING
		else
			switch_generalInfoDisp -> hide := HIDE_WHOLE_CONTROL
		end if
	end if

	if NI_UI_ID = get_ui_id(switch_generalInfoDisp)
		switch_generalInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Articulations info
	if NI_UI_ID = get_ui_id(button_articulationsInfo)
		switch_articulationsInfoDisp -> hide := HIDE_PART_NOTHING
	end if

	if NI_UI_ID = get_ui_id(switch_articulationsInfoDisp)
		switch_articulationsInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Options info
	if NI_UI_ID = get_ui_id(button_optionsInfo)
		button_showMidi := 0
		call update_midi_visibility
		if switch_optionsInfoDisp -> hide = HIDE_WHOLE_CONTROL
			switch_optionsInfoDisp -> hide := HIDE_PART_NOTHING
		else
			switch_optionsInfoDisp -> hide := HIDE_WHOLE_CONTROL
		end if
	end if

	if NI_UI_ID = get_ui_id(switch_optionsInfoDisp)
		switch_optionsInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Speed info
	if NI_UI_ID = get_ui_id(button_speedInfo)
		switch_speedInfoDisp -> hide := HIDE_PART_NOTHING
	end if

	if NI_UI_ID = get_ui_id(switch_speedInfoDisp)
		switch_speedInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Direction info
	if NI_UI_ID = get_ui_id(button_directionInfo)
		switch_directionInfoDisp -> hide := HIDE_PART_NOTHING
	end if

	if NI_UI_ID = get_ui_id(switch_directionInfoDisp)
		switch_directionInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Legato info
	if NI_UI_ID = get_ui_id(button_legatoInfo)
		switch_legatoInfoDisp -> hide := HIDE_PART_NOTHING
	end if

	if NI_UI_ID = get_ui_id(switch_legatoInfoDisp)
		switch_legatoInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if

	// Release samples info
	if NI_UI_ID = get_ui_id(button_releaseSamplesInfo)
		switch_releaseSamplesInfoDisp -> hide := HIDE_PART_NOTHING
	end if

	if NI_UI_ID = get_ui_id(switch_releaseSamplesInfoDisp)
		switch_releaseSamplesInfoDisp -> hide := HIDE_WHOLE_CONTROL
	end if


	index := search(midi_clip_preview_id, NI_UI_ID)
	if index # -1
		set_controller(64, 0)
		wait(1)
		if NI_UI_ID -> value = 0
			playing[clip_poly] := 0
			looping[clip_poly] := 0

			// Stop clicked clip
			get_event_ids(event_ids)
			for e := 0 to num_elements(event_ids) - 1
				if event[event_ids[e]].triggered_by_mf = clip_poly + 1
					fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
					if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
						key_ids[event_ids[e] -> note] -> picture_state := 0
						key_down[event_ids[e] -> note] := 0
						key_active[event_ids[e] -> note] := 0
					end if
				end if
			end for

			cb_id[clip_poly] := NI_CALLBACK_ID
		else
			cb_id[clip_poly] := NI_CALLBACK_ID

			// Release any other midi notes from other clips
			declare other_clip_i
			for other_clip_i := 0 to num_elements(midi_clip_preview_id) - 1
				if index # other_clip_i
					midi_clip_preview_id[other_clip_i] -> value := 0
					if playing[other_clip_i] = 1
						get_event_ids(event_ids)
						for e := 0 to num_elements(event_ids) - 1
							if event[event_ids[e]].triggered_by_mf = other_clip_i + 1
								fade_out(event_ids[e], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
								if in_range(event_ids[e] -> note, LOWEST_KEY, HIGHEST_KEY)
									key_ids[event_ids[e] -> note] -> picture_state := 0
									key_down[event_ids[e] -> note] := 0
									key_active[event_ids[e] -> note] := 0
								end if
							end if
						end for
						playing[other_clip_i] := 0
						looping[other_clip_i] := 0
					end if
				end if
			end for

			//Play
			looping[clip_poly] := 1
			while looping[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
				if clip_loop_enabled[clip_poly] = 0
					looping[clip_poly] := 0
				end if
				if button_showMidi = 0
					looping[clip_poly] := 0
				end if

				cur_event_poly := 0
				
				midi_file_pos_ticks_poly := 0
				time_started[clip_poly] := ENGINE_UPTIME
				call midi_clip_play_cursors

				playing[clip_poly] := 1
				while playing[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
					if cur_event_poly = num_midi_events[clip_poly]
						declare ticks_until_next_event := clip_length[clip_poly] - midi_file_pos_ticks_poly
					else
						ticks_until_next_event := midi_pos[clip_poly, cur_event_poly] - midi_file_pos_ticks_poly
					end if

					if ticks_until_next_event > 0
						wait(ticks_to_ms(ticks_until_next_event))
					end if

					macro check_if_it_should_be_playing
						if cur_event_poly > num_midi_events[clip_poly]
							playing[clip_poly] := 0
						end if
						if button_showMidi = 0
							playing[clip_poly] := 0
						end if
					end macro
					check_if_it_should_be_playing()

					if playing[clip_poly] = 1 and cb_id[clip_poly] = NI_CALLBACK_ID
						midi_file_pos_ticks_poly := midi_file_pos_ticks_poly + ticks_until_next_event
						if midi_command[clip_poly, cur_event_poly] = MIDI_COMMAND_NOTE_ON
							declare note     := midi_byte_1[clip_poly, cur_event_poly]
							declare velocity := midi_byte_2[clip_poly, cur_event_poly]
							declare length   := ticks_to_ms(midi_length[clip_poly, cur_event_poly])
							declare note_id  := play_note(note, velocity, 0, length)
							event[note_id].triggered_by_mf := clip_poly + 1
							event[note_id].source := OUTSIDE_SOURCE
							set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
							note_callback(note, velocity, note_id)
						end if
						if midi_command[clip_poly, cur_event_poly] = MIDI_COMMAND_CC
							declare cc_num := midi_byte_1[clip_poly, cur_event_poly]
							set_controller(cc_num, midi_byte_2[clip_poly, cur_event_poly])
							wait(1)
							controller_callback(cc_num)
						end if
						inc(cur_event_poly)
					end if

					check_if_it_should_be_playing()
				end while
			end while

			// only turn the button off if you'd let the clip run it's course without clicking it again
			if cb_id[clip_poly] = NI_CALLBACK_ID
				NI_UI_ID -> value := 0
			end if
		end if
	end if

	
	// Articulations
	index := search(articulation_ids, NI_UI_ID)
	if index # -1
		cur_artic := index
		call update_articulation_switches
	end if

	// Speed
	if NI_UI_ID = get_ui_id(slider_speed)
		call update_speed_switches
		call update_speed
	end if

	index := search(speed_ids, NI_UI_ID)
	if index # -1
		slider_speed := index
		call update_speed_switches
		call update_speed
	end if

	// Direction
	if NI_UI_ID = get_ui_id(slider_direction)
		call update_direction_switches
	end if

	index := search(direction_mode_ids, NI_UI_ID)
	if index # -1
		slider_direction := index
		call update_direction_switches
	end if

	// Legato/Quantize
	if NI_UI_ID = get_ui_id(slider_legato)
		call update_legato_switches
	end if

	index := search(legato_ids, NI_UI_ID)
	if index # -1
		slider_legato := index
		call update_legato_switches
	end if

	// Release Samples
	if NI_UI_ID = get_ui_id(slider_releaseSamples)
		call update_releaseMode_switches
	end if

	index := search(releaseMode_ids, NI_UI_ID)
	if index # -1
		slider_releaseSamples := index
		call update_releaseMode_switches
	end if

	if NI_UI_ID = get_ui_id(switch_releaseTrigger)
		switch_releaseTrigger := 0
		key_down[recent_release_trigger_key] := 1
		call trigger_release_samples_for_all_ripples
		set_key_pressed(release_trigger_keyswitches[0], 1)
		set_key_pressed(release_trigger_keyswitches[1], 1)
		wait(100000)
		set_key_pressed(release_trigger_keyswitches[0], 0)
		set_key_pressed(release_trigger_keyswitches[1], 0)
	end if


	// Expression
	if NI_UI_ID = get_ui_id(slider_vol)
		if in_range(slider_vol, 0, 500000)
			insert[0].sfx_wet := map_i_2i_2i_i(slider_vol, 0, 500000, V2E.volume2(-16000.0), V2E.volume2(0.0))
		else if in_range(slider_vol, 500000, 1000000)
			insert[0].sfx_wet := map_i_2i_2i_i(slider_vol, 500000, 1000000, V2E.volume2(0.0), V2E.volume2(9000.0))
		end if
		slider_vol -> label := insert[0].sfx_wet.disp & " dB"
	end if

	// Reverb
	if NI_UI_ID = get_ui_id(menu_reverb)
		if menu_reverb = NUM_REVERB_PRESETS // Save
			reverb_preset[prev_reverb, 0] := send[0].raum_type
			reverb_preset[prev_reverb, 1] := send[0].raum_decay
			reverb_preset[prev_reverb, 2] := send[0].raum_size
			reverb_preset[prev_reverb, 3] := send[0].raum_diffusion
			reverb_preset[prev_reverb, 4] := send[0].raum_mod
			reverb_preset[prev_reverb, 5] := send[0].raum_damping
			reverb_preset[prev_reverb, 6] := send[0].raum_lowcut
			reverb_preset[prev_reverb, 7] := send[0].raum_highcut
			menu_reverb := prev_reverb
		else
			send[0].raum_type      := reverb_preset[menu_reverb, 0]
			send[0].raum_decay     := reverb_preset[menu_reverb, 1]
			send[0].raum_size      := reverb_preset[menu_reverb, 2]
			send[0].raum_diffusion := reverb_preset[menu_reverb, 3]
			send[0].raum_mod       := reverb_preset[menu_reverb, 4]
			send[0].raum_damping   := reverb_preset[menu_reverb, 5]
			send[0].raum_lowcut    := reverb_preset[menu_reverb, 6]
			send[0].raum_highcut   := reverb_preset[menu_reverb, 7]
		end if
		call set_reverb_menu_checkmark
		prev_reverb := menu_reverb
	end if

	if NI_UI_ID = get_ui_id(slider_reverb)
		declare ~vol := real(slider_reverb) / 1000000.0
		declare ~db := vol_to_db_safe(vol)
		send[7].send_0 := V2E.volume(db * 1000.0)
		slider_reverb -> label := send[7].send_0.disp
		// main[0].raum_reverb := slider_reverb
	end if


	// Set keys pressed
	if search(articulation_ids  , NI_UI_ID) # -1 ...
	or search(speed_ids         , NI_UI_ID) # -1 ...
	or search(direction_mode_ids, NI_UI_ID) # -1 ...
	or search(legato_ids        , NI_UI_ID) # -1 ...
	or search(releaseMode_ids   , NI_UI_ID) # -1 ...
	or NI_UI_ID = get_ui_id(slider_speed) ...
	or NI_UI_ID = get_ui_id(slider_direction) ...
	or NI_UI_ID = get_ui_id(slider_legato) ...
	or NI_UI_ID = get_ui_id(slider_releaseSamples)
	 	call set_keys_pressed
	end if

	if NI_UI_ID = get_ui_id(switch_logoAnimTrigger)
		label_version -> hide := HIDE_PART_NOTHING
		timestamp_version_shown := ENGINE_UPTIME
		if slider_logoAnim = 0
			slider_logoAnim := 0
			while slider_logoAnim < 127
				inc(slider_logoAnim)
				wait(5000)
			end while
			slider_logoAnim := 0
		end if
	end if
end function
