define V2E_speed(#in#) := 1000000 - (((#in#) - 1) * 90909)

taskfunc update_nks_label(ctrl_index)
	declare ui_id := ctrl_ids[ctrl_index]
	if ui_id # 0
		declare value := ui_id -> value
	end if

	if ctrl_index = control.vol
		ui_id -> label := insert[0].sfx_wet.disp & " dB"

	else if ctrl_index = control.reverb
		ui_id -> label := send[7].send_0.disp

	else if in_range(ctrl_index, control.speed, control.releaseSamples)
		ui_id -> label := option_texts_shortened[ctrl_index, value]

	end if
end taskfunc

taskfunc update_engine_pars(ctrl_index)
	declare ui_id := ctrl_ids[ctrl_index]
	if ui_id # 0
		declare value := ui_id -> value
	end if

	select ctrl_index
		case control.vol
			if in_range(value, 0, 500000)
				insert[0].sfx_wet := map_i_2i_2i_i(value, 0, 500000, V2E.volume2(-16000.0), V2E.volume2(0.0))
			else if in_range(value, 500000, 1000000)
				insert[0].sfx_wet := map_i_2i_2i_i(value, 500000, 1000000, V2E.volume2(0.0), V2E.volume2(9000.0))
			end if

		case control.reverb
			call update_reverb_send_levels

		case control.reverb_type
			call update_reverb_send_levels

		case control.speed
			for g := 0 to NUM_GROUPS - 1
				if switch_halfSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_QUARTER
				end if
				if switch_slowTripletSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_QUARTER_TRIPLET
				end if
				if switch_fullSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_8TH
				end if
				if switch_fastTripletSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_8TH_TRIPLET
				end if
				if switch_doubleSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_16TH
				end if
			end for

		case control.direction
			// Nothing to do

		case control.legato
			// Nothing to do

		case control.releaseSamples
			// Nothing to do

	end select
end taskfunc

function update_reverb_send_levels
	~vol := float(slider_reverb) / 1000000.0
	~db := vol_to_db_safe(vol)
	insert[7].send_0 := is_equal(menu_reverb, 0) * V2E.volume(db * 1000.0)
	insert[7].send_1 := is_equal(menu_reverb, 1) * V2E.volume(db * 1000.0)
	insert[7].send_2 := is_equal(menu_reverb, 2) * V2E.volume(db * 1000.0)
end function


function trigger_release_samples_for_all_ripples
	declare key_i
	for key_i := LOWEST_KEY to HIGHEST_KEY
		key_active[key_i] := 0
		for voice_i := 0 to num_ripple_voices[key_i] - 1
			release(key_i, voice_i)
		end for
		num_ripple_voices[key_i] := 0
		key_down[key_i] := 0
		set_key_pressed(key_i, 0)
	end for
end function

function set_reverb_menu_checkmark
	declare @checkmark
	declare i
	for i := 0 to NUM_REVERB_PRESETS - 1
		if i = menu_reverb
			checkmark := " x "
		else
			checkmark := "    "
		end if
		set_menu_item_str(get_ui_id(menu_reverb), i, checkmark & reverb_preset_names[i])
	end for
end function

function update_midi_visibility()
	switch_closeMidi -> hide := hide_states[button_showMidi]
	paneL_midi -> hide := hide_states[button_showMidi]
	for i := 0 to NUM_MIDI_PAGES - 1
		panel_midiPg[i] -> hide := HIDE_WHOLE_CONTROL
	end for
	panel_midiPg[cur_midi_page] -> hide := hide_states[button_showMidi]
	label_midiInstructions      -> hide := hide_states[button_showMidi]
	midiInstructions_opacity := float(button_showMidi)
	midiCover_opacity := float(button_showMidi)

	panel_articulations    -> hide := hide_states[1 - button_showMidi]
	panel_fx               -> hide := hide_states[1 - button_showMidi]
	panel_speed            -> hide := hide_states[1 - button_showMidi]
	slider_speed           -> hide := hide_states[1 - button_showMidi]
	panel_direction        -> hide := hide_states[1 - button_showMidi]
	slider_direction       -> hide := hide_states[1 - button_showMidi]
	panel_legato           -> hide := hide_states[1 - button_showMidi]
	slider_legato          -> hide := hide_states[1 - button_showMidi]
	panel_releaseSamples   -> hide := hide_states[1 - button_showMidi]
	slider_releaseSamples  -> hide := hide_states[1 - button_showMidi]
	button_generalInfo     -> hide := hide_states[1 - button_showMidi]
	button_optionsInfo     -> hide := hide_states[1 - button_showMidi]
end function


function find_first_active_ripple() -> return
	declare r
	declare found := 0
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] # 0 ...
		and event[ripple_id_history[r]].source = OUTSIDE_SOURCE ...
		and event[ripple_id_history[r]].type # RELEASE_SAMPLE_TYPE ...
		and (event[ripple_id_history[r]].releasing = 0 or slider_legato = legatoMode.syncToSwell) ...
		and ripple_id_history[r] -> play_pos > 0 ...
		and found = 0
			found := 1
			return := ripple_id_history[r]
		end if
	end for

	found := 0
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 and found = 0
			found := 1
			return := r - 1
		end if
	end for
end function

function search_for_note_in_key_history(note) -> return
	declare hist_i
	declare note_found := 0
	for hist_i := 0 to num_elements(key_history) - 1
		if note_found = 0
			if key_history[hist_i] = note
				note_found := 1
				return := hist_i
			end if
		end if
	end for
	if note_found = 0
		return := -1
	end if
end function

function set_key_colors_and_types_and_names
	for key_i := 0 to 127
		set_key_color(key_i, KEY_COLOR_BLACK)
		if search(black_keys, key_i mod 12) # -1
			set_key_color(key_i, KEY_COLOR_WHITE)
		end if
		set_key_type(key_i, NI_KEY_TYPE_NONE)
		set_key_name(key_i, "")

		declare index := search(articulation_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_RED)
			set_key_name(key_i, articulation_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		if in_range(key_i, LOWEST_KEY, HIGHEST_KEY)
			set_key_color(key_i, KEY_COLOR_DEFAULT)
			set_key_type(key_i, NI_KEY_TYPE_DEFAULT)
		end if

		index := search(speed_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_GREEN)
			set_key_name(key_i, speed_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(direction_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_YELLOW)
			set_key_name(key_i, direction_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(legato_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_PURPLE)
			set_key_name(key_i, legato_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(release_sample_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_ORANGE)
			set_key_name(key_i, releaseSamples_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(release_trigger_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_MINT)
			set_key_name(key_i, "Release Trigger Key")
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		// set_key_color(RELEASE_TRIGGER_KEY, KEY_COLOR_RED)
		// set_key_name(RELEASE_TRIGGER_KEY, "Release Trigger Key")
		// set_key_type(key_i, NI_KEY_TYPE_CONTROL)
	end for
end function

function set_keys_pressed
	for i := 0 to NUM_artics - 1
		if i = cur_artic
			set_key_pressed(articulation_keyswitches[i], 1)
		else
			set_key_pressed(articulation_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_speedModes - 1
		if i = slider_speed
			set_key_pressed(speed_keyswitches[i], 1)
		else
			set_key_pressed(speed_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_directionModes - 1
		if i = slider_direction
			set_key_pressed(direction_keyswitches[i], 1)
		else
			set_key_pressed(direction_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_legatoModes - 1
		if i = slider_legato
			set_key_pressed(legato_keyswitches[i], 1)
		else
			set_key_pressed(legato_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_releaseSampleModes - 1
		if i = slider_releaseSamples
			set_key_pressed(release_sample_keyswitches[i], 1)
		else
			set_key_pressed(release_sample_keyswitches[i], 0)
		end if
	end for

end function


function count_active_ripples
	declare found := 0
	declare r
	num_active_ripples := 0
	for r := 1 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 and found = 0
			if key_active[event[ripple_id_history[r-1]].second_note] = 0
				// Need to stop counting ripples as active slightly before they actually finish fading out.
				// This is where we figure that out
				if event[ripple_id_history[r-1]].note_off_timestamp # 0
					declare time_since_note_off := ENGINE_UPTIME - event[ripple_id_history[r-1]].note_off_timestamp
					if time_since_note_off < DURATION_EIGHTH / 1000 + 100
						found := 1
						num_active_ripples := r
					end if
				end if
			else
				found := 1
				num_active_ripples := r
			end if
		end if
	end for
end function

function count_keys_pressed()
	num_keys_pressed := 0
	declare key_i
	for key_i := LOWEST_KEY to HIGHEST_KEY
		if key_active[key_i] = 1
			inc(num_keys_pressed)
		end if
	end for
end function

function update_articulation_switches
	for i := 0 to num_elements(articulation_ids) - 1
		if i = cur_artic
			articulation_ids[i] -> value := 1
		else
			articulation_ids[i] -> value := 0
		end if
	end for
end function

function update_speed_switches
	for i := 0 to num_elements(speed_ids) - 1
		if i = slider_speed
			speed_ids[i] -> value := 1
		else
			speed_ids[i] -> value := 0
		end if
	end for
end function

function update_direction_switches
	for i := 0 to num_elements(direction_ids) - 1
		if i = slider_direction
			direction_ids[i] -> value := 1
		else
			direction_ids[i] -> value := 0
		end if
	end for
end function

function update_legato_switches
	for i := 0 to num_elements(legato_ids) - 1
		if i = slider_legato
			legato_ids[i] -> value := 1
		else
			legato_ids[i] -> value := 0
		end if
	end for
end function

function update_releaseSamples_switches
	for i := 0 to num_elements(releaseSamples_ids) - 1
		if i = slider_releaseSamples
			releaseSamples_ids[i] -> value := 1
		else
			releaseSamples_ids[i] -> value := 0
		end if
	end for
end function



{{ Listener }}
function remove_ripple_ids_from_history_after_they_have_faded_out
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_INACTIVE and ripple_id_history[r] # 0
			ripple[r] -> hide := HIDE_WHOLE_CONTROL // also hide them
			for hist_i := r to MAX_RIPPLE_HISTORY - 2
				ripple_id_history[hist_i] := ripple_id_history[hist_i + 1]
			end for
		end if
	end for
end function

function ripple_animations
	// Hide any ripple graphics that have been removed from history and didn't get a chance to be hidden otherwise
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 //or event_status(ripple_id_history[r]) = EVENT_STATUS_INACTIVE
			ripple[r]       -> hide := HIDE_WHOLE_CONTROL
			ripple_swell[r] -> hide := HIDE_WHOLE_CONTROL
		end if
	end for

	// Draw and animate ripples
	for r := MAX_RIPPLE_HISTORY - 1 downto 0
		if event[ripple_id_history[r]].releasing = 0
			if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
				// Animation Variables
				declare low_note  := event[ripple_id_history[r]].low_note
				declare high_note := event[ripple_id_history[r]].high_note
				declare direction := event[ripple_id_history[r]].direction
				declare interval  := (high_note - low_note) * (direction * 2 - 1)
				
				declare artic := event[ripple_id_history[r]].artic
				declare ~speed_curve
				declare ~brightness_curve
				if artic = artic.quarters
					speed_curve := 1.0
					brightness_curve := 5.0
				else if artic = artic.eighths
					speed_curve := 1.5
					brightness_curve := 2.0
				else if artic = artic.sixteenths
					speed_curve := 0.75
					brightness_curve := 2.0
				end if

				// Ripple position
				declare row := event[ripple_id_history[r]].row
				ripple[r] -> pos_x := panel_keyboard -> pos_x + key_ids[low_note]  -> pos_x + (key_ids[low_note]  -> width / 2)
				if interval < 0
					ripple[r] -> pos_y := panel_keyboard -> pos_y - (22*abs(interval)+1) / 2 - 1
				else
					ripple[r] -> pos_y := panel_keyboard -> pos_y + key_ids[LOWEST_KEY] -> height - (22*abs(interval)+1) / 2
				end if
				ripple[r] -> picture := "ripple " & interval

				// Play Ripple animation
				declare play_pos_in_beat := ripple_id_history[r] -> play_pos mod rec_time_ripple_lengths[artic]
				ripple[r] -> value := map_i_2i_2i_i(play_pos_in_beat, 0, rec_time_ripple_lengths[artic], 0, 127)

				// Ripple visiblity
				ripple[r] -> hide := HIDE_PART_NOTHING

				// Ripple swell
				ripple_swell[r] -> pos_x := ripple[r] -> pos_x
				ripple_swell[r] -> pos_y := ripple[r] -> pos_y
				ripple_swell[r] -> picture := "ripple swell " & interval
				declare pos_in_swell := ripple_id_history[r] -> play_pos mod rec_time_sample_lengths[artic]
				if in_range(pos_in_swell, 0, rec_time_sample_lengths[artic] / 2)
					ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, 0, rec_time_sample_lengths[artic] / 2, 0, 64)
				else
					ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, rec_time_sample_lengths[artic] / 2, rec_time_sample_lengths[artic], 64, 0)
				end if
				ripple_swell[r] -> hide := ripple[r] -> hide
				ripple_swell[r] -> hide := HIDE_PART_NOTHING
				event[ripple_id_history[r]].brightness_on_release := ripple_swell[r] -> value
			end if
		else if event[ripple_id_history[r]].releasing = 1
			ripple[r] -> hide := HIDE_WHOLE_CONTROL
			if ripple_swell[r] -> value > 0
				declare time_since_note_off := ENGINE_UPTIME - event[ripple_id_history[r]].note_off_timestamp
				declare release_length := event[ripple_id_history[r]].release_sample_length / 1000
				declare brightness_on_release := event[ripple_id_history[r]].brightness_on_release
				if release_length = 0
					release_length := 1
				end if
				if brightness_on_release = 0
					brightness_on_release := 1
				end if
				if time_since_note_off > 0
					ripple_swell[r] -> value := map_i_2i_2i_i(time_since_note_off, 0, release_length, brightness_on_release, 0)
				end if
			end if
		end if

	end for
end function

// Probably won't do this
function insert_mf_note(time, note, vel, length)
	declare event_id := mf_insert_event(0, time, MIDI_COMMAND_NOTE_ON, note, vel)
	mf_set_event_par(event_id, EVENT_PAR_NOTE_LENGTH, length)
end function

function update_recorded_midi
	for r := MAX_RIPPLE_HISTORY - 1 downto 0
		if event[ripple_id_history[r]].releasing = 0
			if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
				// ripple_id_history[r] -> play_pos
			end if
		else if event[ripple_id_history[r]].releasing = 1
			if ripple_swell[r] -> value > 0
				
			end if
		end if
	end for
end function


function midi_clip_play_cursors
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		if midi_clip_preview_id[clip_i] -> value = 1
			declare time_played := ENGINE_UPTIME - time_started[clip_i]
			declare clip_length_ms := ticks_to_ms(clip_length[clip_i]) / 1000
			// mf_cursor[clip_i] -> pos_x := map_i_2i_2i_i(time_played, 0, clip_length_ms, CLIP_MARGIN, midi_clip_id[clip_i] -> width - CLIP_MARGIN)
			mf_cursor[clip_i] -> value := map_i_2i_2i_i(time_played, 0, clip_length_ms, 0, 1000)
			mf_cursor[clip_i] -> hide := HIDE_PART_NOTHING
		else
			mf_cursor[clip_i] -> hide := HIDE_WHOLE_CONTROL
		end if
	end for
end function

function info_graphics_animation
	if PLAYED_VOICES_INST > 0 
		midiInstructions_opacity := 0.0
	end if
	smoothed_midiInstructions_opacity := smoothed_midiInstructions_opacity + (midiInstructions_opacity - smoothed_midiInstructions_opacity) / 30.0
	if ~smoothed_midiInstructions_opacity < 0.0001
		~smoothed_midiInstructions_opacity := 0.0
	end if
	label_midiInstructions -> picture_state := map_f_2f_2i_i(smoothed_midiInstructions_opacity, 0.0, 1.0, 0, 127)
	smoothed_midiCover_opacity := smoothed_midiCover_opacity + (midiCover_opacity - smoothed_midiCover_opacity) / 4.0
	if ~smoothed_midiCover_opacity < 0.0001
		~smoothed_midiCover_opacity := 0.0
	end if
	label_midiCover -> picture_state := map_f_2f_2i_i(smoothed_midiCover_opacity, 0.0, 1.0, 0, 127)
end function

function play_release_samples_when_its_time
	declare ripple_ids_waiting_to_trigger_release_sample[MAX_RIPPLE_HISTORY]
	fill(ripple_ids_waiting_to_trigger_release_sample, 0)
	declare num_waiting := 0

	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
			if event[ripple_id_history[r]].waiting_to_trigger_release_sample = 1 ...
			and event[ripple_id_history[r]].type # RELEASE_SAMPLE_TYPE
				ripple_ids_waiting_to_trigger_release_sample[num_waiting] := ripple_id_history[r]
				inc(num_waiting)

				declare time_since_note_off := ENGINE_UPTIME - event[ripple_id_history[r]].note_off_timestamp
				if time_since_note_off > event[ripple_id_history[r]].time_til_note_off - (DURATION_SIXTEENTH / 4 / 1000)
					event[ripple_id_history[r]].waiting_to_trigger_release_sample := 0
					declare artic := event[ripple_id_history[r]].artic

					// Stop ripple
					// Must grab these values from the Ripple before stopping it, though
					declare vol := ripple_id_history[r] -> volume
					declare offset := 50000 // Used to make it err on the side of choosing a ripple that's softer.
					declare play_pos := ripple_id_history[r] -> play_pos
					if play_pos - offset < rec_time_sample_lengths[artic] / 2
						play_pos := play_pos - offset
						if play_pos < 0
							play_pos := 0
						end if
					else
						play_pos := play_pos + offset
					end if
					declare cur_ripple := play_pos / rec_time_ripple_lengths[artic]
					if cur_ripple > 3
						cur_ripple := 4 - (cur_ripple - 3)
					end if
					constrain(cur_ripple, 0, 3)
					declare vel := (cur_ripple * 32 + 1)

					// fade_out(ripple_id_history[r], DURATION_SIXTEENTH / 2, STOP_VOICE_AFTER_FADE_OUT)
					declare fade_out_time := int(float(ticks_to_ms(ripple_length_ticks[artic] / pitch_fractions[artic])) * speeds[slider_speed])
					fade_out(ripple_id_history[r], fade_out_time, STOP_VOICE_AFTER_FADE_OUT)

					
					// Play release-sample
					declare release_sample_will_already_be_triggered := 0
					declare i
					for i := 0 to num_waiting - 1
						if i # r
							if event[ripple_ids_waiting_to_trigger_release_sample[i]].origin_note = event[ripple_id_history[r]].origin_note
								release_sample_will_already_be_triggered := 1
							end if
						end if
					end for
					if release_sample_will_already_be_triggered = 0
						// Set sample start, based on release sample options
						declare sample_start
						declare vel
						if slider_releaseSamples > 0
							select slider_releaseSamples
								case releaseSampleMode.softRelease
									sample_start := rec_time_ripple_lengths[artic] / 2
									vel := 24
								case releaseSampleMode.loudRelease
									sample_start := 0
									vel := 96
							end select
						end if

						// Override sample start if the release trigger key is being used
						if key_down[recent_release_trigger_key] = 1
							vel := velo[recent_release_trigger_key]
							sample_start := map_i_2i_2i_i(vel, 1, 127, rec_time_ripple_lengths[artic] / 2, 0)
						end if

						declare release_sample_length := rec_time_ripple_lengths[artic] - sample_start
						release_sample_length := map_i_2i_2i_i(release_sample_length, 0, rec_time_ripple_lengths[artic], 0, ticks_to_ms(ripple_length_ticks[artic]))
						release_sample_length := int(float(release_sample_length) * speeds[slider_speed])
						event[ripple_id_history[r]].release_sample_length := release_sample_length // for animations

						declare atk_time := map_i_2i_2i_i(vel, 1, 127, ticks_to_ms(ripple_length_ticks[artic] / 2), ticks_to_ms(ripple_length_ticks[artic] / 4)) / 1000
						// declare dec_time := map_i_2i_2i_i(vel, 1, 127, ticks_to_ms(ripple_length_ticks[artic]), 0) / 1000
						declare dec_time := ticks_to_ms(ripple_length_ticks[artic]*3) / 1000
						atk_time := int(float(atk_time) * speeds[slider_speed])
						dec_time := int(float(dec_time) * speeds[slider_speed])
						group[release_group[artic]].mods["ENV_AHDSR2"].target["ENV_AHDSR_VOLUME2"].env_atk := V2E.AtkTime(float(atk_time) * 100.0)
						group[release_group[artic]].mods["ENV_AHDSR2"].target["ENV_AHDSR_VOLUME2"].env_dec := V2E.DRTime(float(dec_time) * 100.0)

						declare note_id := play_note(event[ripple_id_history[r]].origin_note, vel, sample_start, 0)
						set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
						set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, release_group[artic])

						literate_macro(copy_ripple_history_pars_to_note_id_pars) on CUSTOM_EVENT_PARS
						ripple_id_history[r] := note_id

						event[ripple_id_history[r]].note_off_timestamp := ENGINE_UPTIME

						// Release-sample fade and vol
						// declare mod_value := map_i_2i_2i_i(velo[recent_release_trigger_key], 1, 127, 0, 750000)
						// set_event_par_arr(note_id, EVENT_PAR_MOD_VALUE_ID, mod_value, 2)
						// fade_in(note_id, ticks_to_ms(ripple_length_ticks[artic] / 4))
						// wait(1)
						// declare fade_out_time := map_i_2i_2i_i(velo[recent_release_trigger_key], 1, 127, 0, ticks_to_ms(ripple_length_ticks[artic] * 2))
						// msg(fade_out_time)
						// fade_out(note_id, 100000*10, STOP_VOICE_AFTER_FADE_OUT)

						event[note_id].source := OUTSIDE_SOURCE
						event[note_id].type := RELEASE_SAMPLE_TYPE
						change_vol(note_id, vol, CHANGE_ABSOLUTE)
					end if

					event[ripple_id_history[r]].releasing := 1
				end if
			end if
		end if
	end for
end function

function crossfaded_looping
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
			declare artic := event[ripple_id_history[r]].artic
			if event[ripple_id_history[r]].releasing = 0 ...
			and ripple_id_history[r] -> play_pos > rec_time_sample_lengths[artic]
				// duplicate event
				fade_out(ripple_id_history[r], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
				declare offset := ripple_id_history[r] -> play_pos mod rec_time_sample_lengths[artic]
				if event[ripple_id_history[r]].preview_being_stopped = 0
					declare note_id := play_note(ripple_id_history[r] -> note, ripple_id_history[r] -> velocity, offset, 0)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, artic)
					change_vol(note_id, ripple_id_history[r] -> volume, CHANGE_ABSOLUTE)
					fade_in(note_id, DURATION_SIXTEENTH)
					macro copy_ripple_history_pars_to_note_id_pars(#par#)
						event[note_id].#par# := event[ripple_id_history[r]].#par#
					end macro
					literate_macro(copy_ripple_history_pars_to_note_id_pars) on CUSTOM_EVENT_PARS
					ripple_id_history[r] := note_id
				end if
			end if
		end if
	end for
end function

function hide_version
	if ENGINE_UPTIME - timestamp_version_shown > 1000
		label_version -> hide := HIDE_WHOLE_CONTROL
	end if
end function


// function dynamic_release(note)
// 	if note = event[ripple_id_history[r]].second_note ...// the 2nd note is what started the ripple
// 	and event[ripple_id_history[r]].second_note_released = 0
// 		event[ripple_id_history[r]].second_note_released := 1
// 		if event[ripple_id_history[r]].first_note_released = 0
// 			event[ripple_id_history[r]].release_note := event[ripple_id_history[r]].first_note
// 		else
// 			event[ripple_id_history[r]].release_note := event[ripple_id_history[r]].second_note
// 		end if
// 		event[ripple_id_history[r]].note_off_timestamp := ENGINE_UPTIME * 1000
// 		event[ripple_id_history[r]].release_length := time_til_end_of_ripple
// 		event[ripple_id_history[r]].releasing := 1
// 	end if

// 	if note = event[ripple_id_history[r]].first_note ...
// 	and event[ripple_id_history[r]].first_note_released = 0
// 		event[ripple_id_history[r]].first_note_released := 1
// 		if event[ripple_id_history[r]].second_note_released = 0
// 			event[ripple_id_history[r]].release_note := event[ripple_id_history[r]].first_note
// 		end if
// 	end if
// end function

// function immediate_release(note:)
// 	if note = event[ripple_id_history[r]].second_note ...
// 	and event[ripple_id_history[r]].releasing = 0
// 		event[ripple_id_history[r]].releasing := 1

// 		// Stop ripple
// 		fade_out(ripple_id_history[r], time_til_end_of_ripple, STOP_VOICE_AFTER_FADE_OUT)

// 		// Play release-sample
// 		declare offset := ripple_id_history[r] -> play_pos / rec_time_ripple_lengths[artic] * rec_time_ripple_lengths[artic] + rec_time_ripple_lengths[artic]/2
// 		declare length := ticks_to_ms(ripple_length_ticks[artic] / 2)
// 		declare note_id := play_note(ripple_id_history[r] -> note, ripple_id_history[r] -> velocity, offset, length)
// 		set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
// 		set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, get_group_idx("quarters release"))
// 		// fade_in(note_id, time_til_end_of_ripple)

// 		// if recorded_pos_in_ripple < rec_time_ripple_lengths[artic] / 2
// 		// 	declare rls_note := event[ripple_id_history[r]].first_note
// 		// else
// 		// 	rls_note := event[ripple_id_history[r]].second_note
// 		// end if
// 		// declare offset := recorded_pos_in_ripple - (rec_time_ripple_lengths[artic] / 2)
// 		// offset := offset + rec_time_ripple_lengths[artic]/2
// 		// msg(offset)
// 		// declare note_id := play_note(rls_note, event[ripple_id_history[r]].velocity, offset, 0)
// 		// set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
// 		// set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, get_group_idx("releases"))

// 		// // Release-sample fade and vol
// 		// declare fade_in_time := time_til_end_of_ripple/2
// 		// if fade_in_time < DURATION_EIGHTH
// 		// 	fade_in_time := DURATION_EIGHTH
// 		// end if
// 		// msg(fade_in_time)
// 		// fade_in(note_id, fade_in_time)
// 		// declare cur_swell_volume := get_cur_swell_volume(r, artic)
// 		// declare vol := cur_swell_volume + ripple_id_history[r] -> volume
// 		// event[note_id].source := OUTSIDE_SOURCE
// 		// event[note_id].type := RELEASE_SAMPLE
// 		// change_vol(note_id, vol, CHANGE_ABSOLUTE)
// 	end if
// end function
