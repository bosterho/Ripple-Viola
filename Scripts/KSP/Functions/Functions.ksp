taskfunc update_nks_label(ctrl_index)
	declare ui_id := ctrl_ids[ctrl_index]
	if ui_id # 0
		declare value := ui_id -> value
	end if

	select ctrl_index
		case control.vol
			ui_id -> label := insert[0].sfx_wet.disp & " dB"

		case control.reverb
			ui_id -> label := insert[7].send_7.disp & " dB"

		case control.speed to control.releaseSamples
			ui_id -> label := option_texts_shortened[ctrl_index, value]

	end select
end taskfunc

taskfunc update_engine_pars(ctrl_index)
	declare ui_id := ctrl_ids[ctrl_index]
	if ui_id # 0
		declare value := ui_id -> value
	end if

	select ctrl_index
		case control.vol
			if in_range(value, 0, 500000)
				insert[0].sfx_wet := map_i_2i_2i_i(value, 0, 500000, V2E.volume2(-16000.0), V2E.volume2(0.0))
			else if in_range(value, 500000, 1000000)
				insert[0].sfx_wet := map_i_2i_2i_i(value, 500000, 1000000, V2E.volume2(0.0), V2E.volume2(9000.0))
			end if

		case control.reverb
			call update_reverb_send_levels

		case control.reverb_type
			call update_reverb_send_levels

		case control.speed
			for g := 0 to NUM_GROUPS - 1
				if switch_halfSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_QUARTER
				end if
				if switch_slowTripletSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_QUARTER_TRIPLET
				end if
				if switch_fullSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_8TH
				end if
				if switch_fastTripletSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_8TH_TRIPLET
				end if
				if switch_doubleSpeed = 1
					group[g].speed_unit := NI_SYNC_UNIT_16TH
				end if
			end for

		case control.direction
			// Nothing to do

		case control.legato
			// Nothing to do

		case control.releaseSamples
			// Nothing to do

	end select
end taskfunc

function update_reverb_send_levels
	// vol := float(slider_reverb) / 1000000.0
	if in_range(slider_reverb, 0, 500000)
		vol := map_i_2i_2f_f(slider_reverb, 0, 500000, 0.0, 0.5)
	else if in_range(slider_reverb, 500000, 1000000)
		vol := map_i_2i_2f_f(slider_reverb, 500000, 1000000, 0.5, 2.0)
	end if
	db := vol_to_db_safe(vol)
	insert[7].send_0 := is_equal(menu_reverb, 0) * is_equal(switch_reverbToggle, 1) * V2E.volume(db * 1000.0)
	insert[7].send_1 := is_equal(menu_reverb, 1) * is_equal(switch_reverbToggle, 1) * V2E.volume(db * 1000.0)
	insert[7].send_2 := is_equal(menu_reverb, 2) * is_equal(switch_reverbToggle, 1) * V2E.volume(db * 1000.0)

	// Dummy send, for NKS label
	insert[7].send_7 := V2E.volume(db * 1000.0)
end function

function update_reverb_slider_picture
	if switch_reverbToggle = 0
		slider_reverb -> picture := "knob gray"
	else
		slider_reverb -> picture := "knob"
	end if
end function


function trigger_release_samples_for_all_ripples
	declare key_i
	for key_i := LOWEST_KEY to HIGHEST_KEY
		key_active[key_i] := 0
		for voice_i := 0 to num_ripple_voices[key_i] - 1
			release(key_i, voice_i)
		end for
		num_ripple_voices[key_i] := 0
		key_down[key_i] := 0
		set_key_pressed(key_i, 0)
	end for
end function

function set_reverb_menu_checkmark
	declare @checkmark
	declare i
	for i := 0 to NUM_REVERB_PRESETS - 1
		if i = menu_reverb
			checkmark := " x "
		else
			checkmark := "    "
		end if
		set_menu_item_str(get_ui_id(menu_reverb), i, checkmark & reverb_preset_names[i])
	end for
end function

function update_midi_visibility()
	switch_closeMidi -> hide := hide_states[button_showMidi]
	paneL_midi -> hide := hide_states[button_showMidi]
	for i := 0 to NUM_MIDI_PAGES - 1
		panel_midiPg[i] -> hide := HIDE_WHOLE_CONTROL
	end for
	panel_midiPg[cur_midi_page] -> hide := hide_states[button_showMidi]
	label_midiInstructions      -> hide := hide_states[button_showMidi]
	midiInstructions_opacity := float(button_showMidi)
	midiCover_opacity := float(button_showMidi)

	panel_articulations    -> hide := hide_states[1 - button_showMidi]
	panel_fx               -> hide := hide_states[1 - button_showMidi]
	panel_speed            -> hide := hide_states[1 - button_showMidi]
	slider_speed           -> hide := hide_states[1 - button_showMidi]
	panel_direction        -> hide := hide_states[1 - button_showMidi]
	slider_direction       -> hide := hide_states[1 - button_showMidi]
	panel_legato           -> hide := hide_states[1 - button_showMidi]
	slider_legato          -> hide := hide_states[1 - button_showMidi]
	panel_releaseSamples   -> hide := hide_states[1 - button_showMidi]
	slider_releaseSamples  -> hide := hide_states[1 - button_showMidi]
	button_generalInfo     -> hide := hide_states[1 - button_showMidi]
	button_optionsInfo     -> hide := hide_states[1 - button_showMidi]
end function


function find_first_active_ripple() -> return
	declare r
	declare found := 0
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] # 0 ...
		and event[ripple_id_history[r]].source = OUTSIDE_SOURCE ...
		and event[ripple_id_history[r]].type # RELEASE_SAMPLE_TYPE ...
		and (event[ripple_id_history[r]].releasing = 0 or slider_legato = legatoMode.syncToSwell) ...
		and ripple_id_history[r] -> play_pos > 0 ...
		and found = 0
			found := 1
			return := ripple_id_history[r]
		end if
	end for

	found := 0
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 and found = 0
			found := 1
			return := r - 1
		end if
	end for
end function

function search_for_note_in_key_history(note) -> return
	declare hist_i
	declare note_found := 0
	for hist_i := 0 to num_elements(key_history) - 1
		if note_found = 0
			if key_history[hist_i] = note
				note_found := 1
				return := hist_i
			end if
		end if
	end for
	if note_found = 0
		return := -1
	end if
end function

function set_key_colors_and_types_and_names
	for key_i := 0 to 127
		set_key_color(key_i, KEY_COLOR_BLACK)
		if search(black_keys, key_i mod 12) # -1
			set_key_color(key_i, KEY_COLOR_WHITE)
		end if
		set_key_type(key_i, NI_KEY_TYPE_NONE)
		set_key_name(key_i, "")

		declare index := search(articulation_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_RED)
			set_key_name(key_i, articulation_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		if in_range(key_i, LOWEST_KEY, HIGHEST_KEY)
			set_key_color(key_i, KEY_COLOR_DEFAULT)
			set_key_type(key_i, NI_KEY_TYPE_DEFAULT)
		end if

		index := search(speed_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_GREEN)
			set_key_name(key_i, speed_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(direction_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_YELLOW)
			set_key_name(key_i, direction_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(legato_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_PURPLE)
			set_key_name(key_i, legato_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(release_sample_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_ORANGE)
			set_key_name(key_i, releaseSamples_texts[index])
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		index := search(release_trigger_keyswitches, key_i)
		if index # -1
			set_key_color(key_i, KEY_COLOR_MINT)
			set_key_name(key_i, "Release Trigger Key")
			set_key_type(key_i, NI_KEY_TYPE_CONTROL)
		end if

		// set_key_color(RELEASE_TRIGGER_KEY, KEY_COLOR_RED)
		// set_key_name(RELEASE_TRIGGER_KEY, "Release Trigger Key")
		// set_key_type(key_i, NI_KEY_TYPE_CONTROL)
	end for
end function

function set_keys_pressed
	for i := 0 to NUM_artics - 1
		if i = cur_artic
			set_key_pressed(articulation_keyswitches[i], 1)
		else
			set_key_pressed(articulation_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_speedModes - 1
		if i = slider_speed
			set_key_pressed(speed_keyswitches[i], 1)
		else
			set_key_pressed(speed_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_directionModes - 1
		if i = slider_direction
			set_key_pressed(direction_keyswitches[i], 1)
		else
			set_key_pressed(direction_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_legatoModes - 1
		if i = slider_legato
			set_key_pressed(legato_keyswitches[i], 1)
		else
			set_key_pressed(legato_keyswitches[i], 0)
		end if
	end for

	for i := 0 to NUM_releaseSampleModes - 1
		if i = slider_releaseSamples
			set_key_pressed(release_sample_keyswitches[i], 1)
		else
			set_key_pressed(release_sample_keyswitches[i], 0)
		end if
	end for

end function


function count_active_ripples
	declare found := 0
	declare r
	num_active_ripples := 0
	for r := 1 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 and found = 0
			if key_active[event[ripple_id_history[r-1]].second_note] = 0
				// Need to stop counting ripples as active slightly before they actually finish fading out.
				// This is where we figure that out
				if event[ripple_id_history[r-1]].note_off_timestamp # 0
					declare time_since_note_off := ENGINE_UPTIME - event[ripple_id_history[r-1]].note_off_timestamp
					if time_since_note_off < DURATION_EIGHTH / 1000 + 100
						found := 1
						num_active_ripples := r
					end if
				end if
			else
				found := 1
				num_active_ripples := r
			end if
		end if
	end for
end function

function count_keys_pressed()
	num_keys_pressed := 0
	declare key_i
	for key_i := LOWEST_KEY to HIGHEST_KEY
		if key_active[key_i] = 1
			inc(num_keys_pressed)
		end if
	end for
end function

function update_articulation_switches
	for i := 0 to num_elements(articulation_ids) - 1
		if i = cur_artic
			articulation_ids[i] -> value := 1
		else
			articulation_ids[i] -> value := 0
		end if
	end for
end function

function update_speed_switches
	for i := 0 to num_elements(speed_ids) - 1
		if i = slider_speed
			speed_ids[i] -> value := 1
		else
			speed_ids[i] -> value := 0
		end if
	end for
end function

function update_direction_switches
	for i := 0 to num_elements(direction_ids) - 1
		if i = slider_direction
			direction_ids[i] -> value := 1
		else
			direction_ids[i] -> value := 0
		end if
	end for
end function

function update_legato_switches
	for i := 0 to num_elements(legato_ids) - 1
		if i = slider_legato
			legato_ids[i] -> value := 1
		else
			legato_ids[i] -> value := 0
		end if
	end for
end function

function update_releaseSamples_switches
	for i := 0 to num_elements(releaseSamples_ids) - 1
		if i = slider_releaseSamples
			releaseSamples_ids[i] -> value := 1
		else
			releaseSamples_ids[i] -> value := 0
		end if
	end for
end function



{{ Listener }}
function remove_ripple_ids_from_history_after_they_have_faded_out
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_INACTIVE and ripple_id_history[r] # 0
			ripple[r] -> hide := HIDE_WHOLE_CONTROL // also hide them
			for hist_i := r to MAX_RIPPLE_HISTORY - 2
				ripple_id_history[hist_i] := ripple_id_history[hist_i + 1]
			end for
		end if
	end for
end function

function ripple_animations
	// Hide any ripple graphics that have been removed from history and didn't get a chance to be hidden otherwise
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if ripple_id_history[r] = 0 //or event_status(ripple_id_history[r]) = EVENT_STATUS_INACTIVE
			ripple[r]       -> hide := HIDE_WHOLE_CONTROL
			ripple_swell[r] -> hide := HIDE_WHOLE_CONTROL
		end if
	end for

	// Draw and animate ripples
	for r := MAX_RIPPLE_HISTORY - 1 downto 0
		if event[ripple_id_history[r]].releasing = 0
			if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
				// Animation Variables
				declare low_note  := event[ripple_id_history[r]].low_note
				declare high_note := event[ripple_id_history[r]].high_note
				declare direction := event[ripple_id_history[r]].direction
				declare interval  := (high_note - low_note) * (direction * 2 - 1)
				
				declare artic := event[ripple_id_history[r]].artic
				declare ~speed_curve
				declare ~brightness_curve
				if artic = artic.quarters
					speed_curve := 1.0
					brightness_curve := 5.0
				else if artic = artic.eighths
					speed_curve := 1.5
					brightness_curve := 2.0
				else if artic = artic.sixteenths
					speed_curve := 0.75
					brightness_curve := 2.0
				end if

				// Ripple position
				ripple[r] -> pos_x := panel_keyboard -> pos_x + key_ids[low_note]  -> pos_x + (key_ids[low_note]  -> width / 2)
				if interval < 0
					ripple[r] -> pos_y := panel_keyboard -> pos_y - (22*abs(interval)+1) / 2 - 1
				else
					ripple[r] -> pos_y := panel_keyboard -> pos_y + key_ids[LOWEST_KEY] -> height - (22*abs(interval)+1) / 2
				end if
				ripple[r] -> picture := "ripple " & interval

				// Play Ripple animation
				declare play_pos_in_beat := ripple_id_history[r] -> play_pos mod rec_time_ripple_lengths[artic]
				ripple[r] -> value := map_i_2i_2i_i(play_pos_in_beat, 0, rec_time_ripple_lengths[artic], 0, 127)

				// Ripple visiblity
				ripple[r] -> hide := HIDE_PART_NOTHING

				// Ripple swell
				ripple_swell[r] -> pos_x := ripple[r] -> pos_x
				ripple_swell[r] -> pos_y := ripple[r] -> pos_y
				ripple_swell[r] -> picture := "ripple swell " & interval
				declare pos_in_swell := ripple_id_history[r] -> play_pos mod rec_time_sample_lengths[artic]
				if in_range(pos_in_swell, 0, rec_time_sample_lengths[artic] / 2)
					ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, 0, rec_time_sample_lengths[artic] / 2, 0, 64)
				else
					ripple_swell[r] -> value := map_i_2i_2i_i(pos_in_swell, rec_time_sample_lengths[artic] / 2, rec_time_sample_lengths[artic], 64, 0)
				end if
				ripple_swell[r] -> hide := ripple[r] -> hide
				ripple_swell[r] -> hide := HIDE_PART_NOTHING
				event[ripple_id_history[r]].brightness_when_released := ripple_swell[r] -> value
			end if
		else if event[ripple_id_history[r]].releasing = 1
			ripple[r] -> hide := HIDE_WHOLE_CONTROL
			if ripple_swell[r] -> value > 0
				declare time_since_note_off := ENGINE_UPTIME - event[ripple_id_history[r]].note_off_timestamp
				declare release_length := event[ripple_id_history[r]].release_sample_length / 1000
				declare brightness_when_released := event[ripple_id_history[r]].brightness_when_released
				if release_length = 0
					release_length := 1
				end if
				if brightness_when_released = 0
					brightness_when_released := 1
				end if
				if time_since_note_off > 0
					ripple_swell[r] -> value := map_i_2i_2i_i(time_since_note_off, 0, release_length, brightness_when_released, 0)
				end if
			end if
		end if

	end for
end function

// Probably won't do this
function insert_mf_note(time, note, vel, length)
	declare event_id := mf_insert_event(0, time, MIDI_COMMAND_NOTE_ON, note, vel)
	mf_set_event_par(event_id, EVENT_PAR_NOTE_LENGTH, length)
end function

function update_recorded_midi
	for r := MAX_RIPPLE_HISTORY - 1 downto 0
		if event[ripple_id_history[r]].releasing = 0
			if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
				// ripple_id_history[r] -> play_pos
			end if
		else if event[ripple_id_history[r]].releasing = 1
			if ripple_swell[r] -> value > 0
				
			end if
		end if
	end for
end function


function midi_clip_play_cursors
	for clip_i := 0 to NUM_MIDI_CLIPS - 1
		if midi_clip_preview_id[clip_i] -> value = 1
			declare time_played := ENGINE_UPTIME - time_started[clip_i]
			declare clip_length_ms := ticks_to_ms(clip_length[clip_i]) / 1000
			// mf_cursor[clip_i] -> pos_x := map_i_2i_2i_i(time_played, 0, clip_length_ms, CLIP_MARGIN, midi_clip_id[clip_i] -> width - CLIP_MARGIN)
			mf_cursor[clip_i] -> value := map_i_2i_2i_i(time_played, 0, clip_length_ms, 0, 1000)
			mf_cursor[clip_i] -> hide := HIDE_PART_NOTHING
		else
			mf_cursor[clip_i] -> hide := HIDE_WHOLE_CONTROL
		end if
	end for
end function

function info_graphics_animation
	if PLAYED_VOICES_INST > 0 
		midiInstructions_opacity := 0.0
	end if
	smoothed_midiInstructions_opacity := smoothed_midiInstructions_opacity + (midiInstructions_opacity - smoothed_midiInstructions_opacity) / 30.0
	if ~smoothed_midiInstructions_opacity < 0.0001
		~smoothed_midiInstructions_opacity := 0.0
	end if
	label_midiInstructions -> picture_state := map_f_2f_2i_i(smoothed_midiInstructions_opacity, 0.0, 1.0, 0, 127)
	smoothed_midiCover_opacity := smoothed_midiCover_opacity + (midiCover_opacity - smoothed_midiCover_opacity) / 4.0
	if ~smoothed_midiCover_opacity < 0.0001
		~smoothed_midiCover_opacity := 0.0
	end if
	label_midiCover -> picture_state := map_f_2f_2i_i(smoothed_midiCover_opacity, 0.0, 1.0, 0, 127)
end function

function play_release_samples_when_its_time
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
			if event[ripple_id_history[r]].waiting_to_trigger_release_sample = 1 ...
			and event[ripple_id_history[r]].type # RELEASE_SAMPLE_TYPE

				declare artic := event[ripple_id_history[r]].artic
				declare release_dynamic := event[ripple_id_history[r]].release_dynamic
				declare rec_time_pos_in_ripple := ripple_id_history[r] -> play_pos mod rec_time_ripple_lengths[artic]
				// if release_dynamic = SHORT
				// 	if rec_time_pos_in_ripple > rec_time_ripple_lengths[artic] / 2
				// 		fade_out(ripple_id_history[r], ticks_to_ms(ripple_length_ticks[artic] / 2), STOP_VOICE_AFTER_FADE_OUT)
				// 	end if
				// else if release_dynamic = LONG
					if artic = artic.sixteenths
						if rec_time_pos_in_ripple > rec_time_ripple_lengths[artic] / 4 * 3
							fade_out(ripple_id_history[r], ticks_to_ms(ripple_length_ticks[artic] / 4), STOP_VOICE_AFTER_FADE_OUT)
						end if
					else
						if rec_time_pos_in_ripple > rec_time_ripple_lengths[artic] / 8 * 7
							fade_out(ripple_id_history[r], ticks_to_ms(ripple_length_ticks[artic] / 4), STOP_VOICE_AFTER_FADE_OUT)
						end if
					end if
				// end if
				
				if rec_time_pos_in_ripple < event[ripple_id_history[r]].prev_rec_time_pos_in_ripple // If it has wrapped
					event[ripple_id_history[r]].waiting_to_trigger_release_sample := 0

					// Grab these values right before the ripple finishes fading out
					declare vol := ripple_id_history[r] -> volume
					declare offset := 50000 // Used to make it err on the side of choosing a ripple that's softer.
					declare play_pos := ripple_id_history[r] -> play_pos
					if play_pos - offset < rec_time_sample_lengths[artic] / 2
						play_pos := play_pos - offset
						if play_pos < 0
							play_pos := 0
						end if
					else
						play_pos := play_pos + offset
					end if
					declare cur_ripple := play_pos / rec_time_ripple_lengths[artic]
					if cur_ripple > 3
						cur_ripple := 4 - (cur_ripple - 3)
					end if
					constrain(cur_ripple, 0, 3)
					declare vel := (cur_ripple * 32 + 1)

					// Play release-sample
					declare sample_start
					declare fade_time
					if release_dynamic = SHORT
						sample_start := int(float(rec_time_ripple_lengths[artic]) / 3.5)
						// fade_time := 100000
						fade_time := ticks_to_ms(int(float(ripple_length_ticks[artic]) * speeds[artic] / 7.0))
					else if release_dynamic = LONG
						sample_start := 0
						// fade_time := 50000
						fade_time := ticks_to_ms(int(float(ripple_length_ticks[artic]) * speeds[artic] / 15.0))
					end if
					// msg(fade_time)

					group[release_group[artic]].mods["ENV_AHDSR"].target["ENV_AHDSR_VOLUME"].env_atk := V2E.AtkTime(float(fade_time) / 10.0)

					declare release_sample_length := rec_time_ripple_lengths[artic] - sample_start
					release_sample_length := map_i_2i_2i_i(release_sample_length, 0, rec_time_ripple_lengths[artic], 0, ticks_to_ms(ripple_length_ticks[artic]))
					release_sample_length := int(float(release_sample_length) * speeds[slider_speed])
					event[ripple_id_history[r]].release_sample_length := release_sample_length // for animations

					declare note := event[ripple_id_history[r]].origin_note
					fade_out(rls_note_ids[note], fade_time, STOP_VOICE_AFTER_FADE_OUT) // cut off redundant release samples
					declare note_id := play_note(note, vel, sample_start, 0)
					rls_note_ids[note] := note_id
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, release_group[artic])

					literate_macro(copy_ripple_history_pars_to_note_id_pars) on CUSTOM_EVENT_PARS
					ripple_id_history[r] := note_id


					event[note_id].source := OUTSIDE_SOURCE
					event[note_id].type := RELEASE_SAMPLE_TYPE
					change_vol(note_id, vol, CHANGE_ABSOLUTE)

					event[ripple_id_history[r]].note_off_timestamp := ENGINE_UPTIME
					event[ripple_id_history[r]].releasing := 1
				end if
				event[ripple_id_history[r]].prev_rec_time_pos_in_ripple := rec_time_pos_in_ripple
			end if
		end if
	end for
end function

function crossfaded_looping
	for r := 0 to MAX_RIPPLE_HISTORY - 1
		if event_status(ripple_id_history[r]) = EVENT_STATUS_NOTE_QUEUE
			declare artic := event[ripple_id_history[r]].artic
			if event[ripple_id_history[r]].releasing = 0 ...
			and ripple_id_history[r] -> play_pos > rec_time_sample_lengths[artic]
				// duplicate event
				fade_out(ripple_id_history[r], DURATION_SIXTEENTH, STOP_VOICE_AFTER_FADE_OUT)
				declare offset := ripple_id_history[r] -> play_pos mod rec_time_sample_lengths[artic]
				if event[ripple_id_history[r]].preview_being_stopped = 0
					declare note_id := play_note(ripple_id_history[r] -> note, ripple_id_history[r] -> velocity, offset, 0)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 0, ALL_GROUPS)
					set_event_par_arr(note_id, EVENT_PAR_ALLOW_GROUP, 1, artic)
					change_vol(note_id, ripple_id_history[r] -> volume, CHANGE_ABSOLUTE)
					fade_in(note_id, DURATION_SIXTEENTH)
					macro copy_ripple_history_pars_to_note_id_pars(#par#)
						event[note_id].#par# := event[ripple_id_history[r]].#par#
					end macro
					literate_macro(copy_ripple_history_pars_to_note_id_pars) on CUSTOM_EVENT_PARS
					ripple_id_history[r] := note_id
				end if
			end if
		end if
	end for
end function

function hide_version
	if ENGINE_UPTIME - timestamp_version_shown > 1000
		label_version -> hide := HIDE_WHOLE_CONTROL
	end if
end function